diff --git a/Cargo.lock b/Cargo.lock
index 3890171..2ce5523 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -20,16 +20,16 @@ dependencies = [
 
 [[package]]
 name = "algebra"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "algebra-core",
 ]
 
 [[package]]
 name = "algebra-core"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "algebra-core-derive",
  "derivative",
@@ -43,8 +43,8 @@ dependencies = [
 
 [[package]]
 name = "algebra-core-derive"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "proc-macro2 1.0.18",
  "quote 1.0.7",
@@ -97,8 +97,8 @@ checksum = "f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d"
 
 [[package]]
 name = "bench-utils"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "colored",
 ]
@@ -160,6 +160,7 @@ name = "bls-gadgets"
 version = "0.1.4"
 dependencies = [
  "algebra",
+ "algebra-core",
  "bls-crypto",
  "crypto-primitives",
  "groth16",
@@ -168,6 +169,7 @@ dependencies = [
  "rand",
  "rand_xorshift",
  "tracing",
+ "tracing-subscriber",
 ]
 
 [[package]]
@@ -388,8 +390,8 @@ dependencies = [
 
 [[package]]
 name = "crypto-primitives"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "algebra-core",
  "bench-utils",
@@ -403,6 +405,7 @@ dependencies = [
  "r1cs-std",
  "rand",
  "rayon",
+ "tracing",
 ]
 
 [[package]]
@@ -471,6 +474,7 @@ name = "epoch-snark"
 version = "0.1.4"
 dependencies = [
  "algebra",
+ "algebra-core",
  "bench-utils",
  "blake2s_simd",
  "bls-crypto",
@@ -490,8 +494,8 @@ dependencies = [
 
 [[package]]
 name = "ff-fft"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "algebra-core",
  "rand",
@@ -500,8 +504,8 @@ dependencies = [
 
 [[package]]
 name = "field-assembly"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "mince",
 ]
@@ -528,8 +532,8 @@ dependencies = [
 
 [[package]]
 name = "gm17"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "algebra-core",
  "bench-utils",
@@ -537,13 +541,12 @@ dependencies = [
  "r1cs-core",
  "rand",
  "rayon",
- "smallvec",
 ]
 
 [[package]]
 name = "groth16"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "algebra-core",
  "bench-utils",
@@ -679,8 +682,8 @@ dependencies = [
 
 [[package]]
 name = "mince"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "quote 1.0.7",
  "syn 1.0.33",
@@ -801,21 +804,23 @@ dependencies = [
 
 [[package]]
 name = "r1cs-core"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "algebra-core",
- "smallvec",
+ "tracing",
+ "tracing-subscriber",
 ]
 
 [[package]]
 name = "r1cs-std"
-version = "0.1.0"
-source = "git+https://github.com/scipr-lab/zexe#48aab0ddfb8a29941e07a732a6cdd008a7ef3467"
+version = "0.1.1-alpha.0"
+source = "git+https://github.com/scipr-lab/zexe?branch=better-r1cs-docs#982aaf9baa2538e9c742949c281124bd39a20a5a"
 dependencies = [
  "algebra",
  "derivative",
  "r1cs-core",
+ "tracing",
 ]
 
 [[package]]
diff --git a/crates/bls-crypto/Cargo.toml b/crates/bls-crypto/Cargo.toml
index 4cc7e0d..c3774cb 100644
--- a/crates/bls-crypto/Cargo.toml
+++ b/crates/bls-crypto/Cargo.toml
@@ -5,9 +5,9 @@ authors = ["Kobi Gurkan <kobigurk@gmail.com>", "Michael Straka <mstraka@celo.org
 edition = "2018"
 
 [dependencies]
-algebra = { git = "https://github.com/scipr-lab/zexe", features = ["derive", "bls12_377", "ed_on_bw6_761", "parallel"] }
-crypto-primitives = { git = "https://github.com/scipr-lab/zexe", features = ["parallel"] }
-bench-utils = { git = "https://github.com/scipr-lab/zexe" }
+algebra = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", features = ["derive", "bls12_377", "ed_on_bw6_761", "parallel"] }
+crypto-primitives = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", features = ["parallel"] }
+bench-utils = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs" }
 
 # other deps
 rand = { version = "0.7" }
diff --git a/crates/bls-crypto/examples/simple_signature.rs b/crates/bls-crypto/examples/simple_signature.rs
index 6892ee1..2817457 100644
--- a/crates/bls-crypto/examples/simple_signature.rs
+++ b/crates/bls-crypto/examples/simple_signature.rs
@@ -2,7 +2,7 @@ use bls_crypto::{
     hash_to_curve::try_and_increment::COMPOSITE_HASH_TO_G1, PrivateKey, PublicKey, Signature,
 };
 
-use algebra::{to_bytes, ToBytes};
+use algebra::to_bytes;
 
 use clap::{App, Arg};
 use rand::thread_rng;
diff --git a/crates/bls-crypto/src/bls/public.rs b/crates/bls-crypto/src/bls/public.rs
index 0d32a97..2ddea79 100644
--- a/crates/bls-crypto/src/bls/public.rs
+++ b/crates/bls-crypto/src/bls/public.rs
@@ -101,11 +101,11 @@ impl PublicKey {
 }
 
 impl CanonicalSerialize for PublicKey {
-    fn serialize<W: Write>(&self, writer: &mut W) -> Result<(), SerializationError> {
+    fn serialize<W: Write>(&self, writer: W) -> Result<(), SerializationError> {
         self.0.into_affine().serialize(writer)
     }
 
-    fn serialize_uncompressed<W: Write>(&self, writer: &mut W) -> Result<(), SerializationError> {
+    fn serialize_uncompressed<W: Write>(&self, writer: W) -> Result<(), SerializationError> {
         self.0.into_affine().serialize_uncompressed(writer)
     }
 
@@ -115,13 +115,13 @@ impl CanonicalSerialize for PublicKey {
 }
 
 impl CanonicalDeserialize for PublicKey {
-    fn deserialize<R: Read>(reader: &mut R) -> Result<Self, SerializationError> {
+    fn deserialize<R: Read>(reader: R) -> Result<Self, SerializationError> {
         Ok(PublicKey::from(
             G2Affine::deserialize(reader)?.into_projective(),
         ))
     }
 
-    fn deserialize_uncompressed<R: Read>(reader: &mut R) -> Result<Self, SerializationError> {
+    fn deserialize_uncompressed<R: Read>(reader: R) -> Result<Self, SerializationError> {
         Ok(PublicKey::from(
             G2Affine::deserialize_uncompressed(reader)?.into_projective(),
         ))
diff --git a/crates/bls-crypto/src/bls/signature.rs b/crates/bls-crypto/src/bls/signature.rs
index b9230fa..c095c40 100644
--- a/crates/bls-crypto/src/bls/signature.rs
+++ b/crates/bls-crypto/src/bls/signature.rs
@@ -30,11 +30,11 @@ impl AsRef<G1Projective> for Signature {
 }
 
 impl CanonicalSerialize for Signature {
-    fn serialize<W: Write>(&self, writer: &mut W) -> Result<(), SerializationError> {
+    fn serialize<W: Write>(&self, writer: W) -> Result<(), SerializationError> {
         self.0.into_affine().serialize(writer)
     }
 
-    fn serialize_uncompressed<W: Write>(&self, writer: &mut W) -> Result<(), SerializationError> {
+    fn serialize_uncompressed<W: Write>(&self, writer: W) -> Result<(), SerializationError> {
         self.0.into_affine().serialize_uncompressed(writer)
     }
 
@@ -44,13 +44,13 @@ impl CanonicalSerialize for Signature {
 }
 
 impl CanonicalDeserialize for Signature {
-    fn deserialize<R: Read>(reader: &mut R) -> Result<Self, SerializationError> {
+    fn deserialize<R: Read>(reader: R) -> Result<Self, SerializationError> {
         Ok(Signature::from(
             G1Affine::deserialize(reader)?.into_projective(),
         ))
     }
 
-    fn deserialize_uncompressed<R: Read>(reader: &mut R) -> Result<Self, SerializationError> {
+    fn deserialize_uncompressed<R: Read>(reader: R) -> Result<Self, SerializationError> {
         Ok(Signature::from(
             G1Affine::deserialize_uncompressed(reader)?.into_projective(),
         ))
diff --git a/crates/bls-crypto/src/hash_to_curve/try_and_increment.rs b/crates/bls-crypto/src/hash_to_curve/try_and_increment.rs
index 76c7930..0dd7ac7 100644
--- a/crates/bls-crypto/src/hash_to_curve/try_and_increment.rs
+++ b/crates/bls-crypto/src/hash_to_curve/try_and_increment.rs
@@ -113,6 +113,7 @@ where
                 }
                 candidate_hash
             };
+            println!("{:?}", candidate_hash);
 
             if let Some(p) = GroupAffine::<P>::from_random_bytes(&candidate_hash[..num_bytes]) {
                 trace!(
@@ -180,6 +181,7 @@ mod test {
         hash_to_curve_test::<<Parameters as Bls12Parameters>::G2Parameters, _>(h)
     }
 
+    #[allow(unused)]
     fn hash_to_curve_test<P: SWModelParameters, X: Hasher<Error = BLSError>>(h: X) {
         let hasher = TryAndIncrement::<X, P>::new(&h);
         let mut rng = rand::thread_rng();
diff --git a/crates/bls-crypto/src/hashers/composite.rs b/crates/bls-crypto/src/hashers/composite.rs
index ea570f6..118e0ca 100644
--- a/crates/bls-crypto/src/hashers/composite.rs
+++ b/crates/bls-crypto/src/hashers/composite.rs
@@ -3,11 +3,11 @@
 //! Blake2x as the XOF
 use crate::{hashers::DirectHasher, BLSError, Hasher};
 
-use algebra::{ed_on_bw6_761::EdwardsProjective as Edwards, CanonicalSerialize, ProjectiveCurve};
+use algebra::{ed_on_bw6_761::{EdwardsParameters, EdwardsProjective}, CanonicalSerialize, ProjectiveCurve};
 
 use blake2s_simd::Params;
 use crypto_primitives::crh::{
-    bowe_hopwood::BoweHopwoodPedersenCRH, pedersen::PedersenWindow, FixedLengthCRH,
+    bowe_hopwood, pedersen, FixedLengthCRH,
 };
 use once_cell::sync::Lazy;
 use rand::{Rng, SeedableRng};
@@ -15,13 +15,13 @@ use rand_chacha::ChaChaRng;
 
 // Fix to get around leaking a private type in a public interface
 mod window {
-    use super::PedersenWindow;
+    use super::pedersen;
 
     /// The window which will be used with the Fixed Length CRH
     #[derive(Clone)]
     pub struct Window;
 
-    impl PedersenWindow for Window {
+    impl pedersen::Window for Window {
         const WINDOW_SIZE: usize = 93;
         const NUM_WINDOWS: usize = 560;
     }
@@ -29,7 +29,7 @@ mod window {
 
 /// Bowe Hopwood Pedersen CRH instantiated over Edwards BW6_761 with `WINDOW_SIZE = 93` and
 /// `NUM_WINDOWS = 560`
-pub type CRH = BoweHopwoodPedersenCRH<Edwards, window::Window>;
+pub type CRH = bowe_hopwood::CRH<EdwardsParameters, window::Window>;
 
 /// Lazily evaluated composite hasher instantiated over the
 /// Bowe-Hopwood-Pedersen CRH.
@@ -72,7 +72,7 @@ impl<H: FixedLengthCRH> CompositeHasher<H> {
     }
 }
 
-impl<H: FixedLengthCRH<Output = Edwards>> Hasher for CompositeHasher<H> {
+impl<H: FixedLengthCRH<Output = EdwardsProjective>> Hasher for CompositeHasher<H> {
     type Error = BLSError;
 
     // TODO: Should we improve the trait design somehow? Seems like there's a bad abstraction
diff --git a/crates/bls-crypto/src/hashers/mod.rs b/crates/bls-crypto/src/hashers/mod.rs
index ee68663..5ee189b 100644
--- a/crates/bls-crypto/src/hashers/mod.rs
+++ b/crates/bls-crypto/src/hashers/mod.rs
@@ -37,6 +37,7 @@ pub trait Hasher {
         output_size_in_bytes: usize,
     ) -> Result<Vec<u8>, Self::Error> {
         let prepared_message = self.crh(domain, message, output_size_in_bytes)?;
+        println!("pedersen output normal: {:?}", prepared_message);
         self.xof(domain, &prepared_message, output_size_in_bytes)
     }
 }
diff --git a/crates/bls-gadgets/Cargo.toml b/crates/bls-gadgets/Cargo.toml
index 21ca060..6df93b0 100644
--- a/crates/bls-gadgets/Cargo.toml
+++ b/crates/bls-gadgets/Cargo.toml
@@ -7,10 +7,11 @@ edition = "2018"
 [dependencies]
 bls-crypto = { path = "../bls-crypto", default-features = false }
 
-algebra = { git = "https://github.com/scipr-lab/zexe", default-features = false, features = ["bls12_377", "bw6_761", "ed_on_bw6_761", "ed_on_bls12_377", "parallel"] }
-r1cs-core = { git = "https://github.com/scipr-lab/zexe", default-features = false }
-r1cs-std = { git = "https://github.com/scipr-lab/zexe", default-features = false, features = ["bls12_377", "ed_on_cp6_782", "parallel"] }
-crypto-primitives = { git = "https://github.com/scipr-lab/zexe", default-features = false, features = ["parallel"] }
+algebra = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", default-features = false, features = ["bls12_377", "bw6_761", "ed_on_bw6_761", "ed_on_bls12_377", "parallel"] }
+algebra-core = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs" } 
+r1cs-core = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", default-features = false }
+r1cs-std = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", default-features = false, features = ["bls12_377", "ed_on_cp6_782", "parallel"] }
+crypto-primitives = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", default-features = false, features = ["parallel"] }
 
 # used only when exporting our test helpers to be used in the snark crate
 rand_xorshift = { version = "0.2", optional = true }
@@ -20,8 +21,9 @@ tracing = "0.1.13"
 [dev-dependencies]
 rand_xorshift = { version = "0.2" }
 rand = { version = "0.7" }
-groth16 = { git = "https://github.com/scipr-lab/zexe" }
+groth16 = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs" }
 bls-crypto = { path = "../bls-crypto", default-features = false, features = ["test-helpers"] }
+tracing-subscriber = { version = "0.2" }
 
 [features]
 default = ["compat"]
diff --git a/crates/bls-gadgets/src/bitmap.rs b/crates/bls-gadgets/src/bitmap.rs
index d8b2a3a..6d9a786 100644
--- a/crates/bls-gadgets/src/bitmap.rs
+++ b/crates/bls-gadgets/src/bitmap.rs
@@ -1,75 +1,87 @@
 use crate::utils::is_setup;
 use algebra::PrimeField;
-use r1cs_core::{ConstraintSystem, LinearCombination, SynthesisError};
+use r1cs_core::{LinearCombination, lc, SynthesisError, Variable, ConstraintSystemRef, ConstraintSystem};
 use r1cs_std::{
-    fields::{fp::FpGadget, FieldGadget},
+    fields::{fp::FpVar},
     prelude::*,
-    Assignment,
 };
 
-/// Enforces that there are no more than `max_occurrences` of `value` (0 or 1)
-/// present in the provided bitmap
-pub fn enforce_maximum_occurrences_in_bitmap<F: PrimeField, CS: ConstraintSystem<F>>(
-    cs: &mut CS,
-    bitmap: &[Boolean],
-    max_occurrences: &FpGadget<F>,
-    value: bool,
-) -> Result<(), SynthesisError> {
-    let mut value_fp = F::one();
-    if !value {
-        // using the opposite value if we are counting 0s
-        value_fp = value_fp.neg();
-    }
-    // If we're in setup mode, we skip the bit counting part since the bitmap
-    // will be empty
-    let is_setup = is_setup(&bitmap);
-
-    let mut occurrences = 0;
-    let mut occurrences_lc = LinearCombination::zero();
-    // For each bit, increment the number of occurences if the bit matched `value`
-    // We calculate both the number of occurrences
-    // and a linear combination over it, in order to do 2 things:
-    // 1. enforce that occurrences < maximum_occurences
-    // 2. enforce that occurrences was calculated correctly from the bitmap
-    for bit in bitmap {
-        // Update the constraints
+pub trait Bitmap<F: PrimeField> {
+    fn enforce_maximum_occurrences_in_bitmap( 
+        &self,
+        max_occurrences: &FpVar<F>,
+        value: bool,
+    ) -> Result<(), SynthesisError>;
+}
+
+impl<F: PrimeField> Bitmap<F> for [Boolean<F>] {
+    /// Enforces that there are no more than `max_occurrences` of `value` (0 or 1)
+    /// present in the provided bitmap
+    // TODO: Handle constant Boolean values in bitmap
+    fn enforce_maximum_occurrences_in_bitmap(
+        &self,
+        max_occurrences: &FpVar<F>,
+        value: bool,
+    ) -> Result<(), SynthesisError> {
+        let mut value_fp = F::one();
         if !value {
-            // add 1 here only for zeros
-            occurrences_lc += (F::one(), CS::one());
+            // using the opposite value if we are counting 0s
+            value_fp = value_fp.neg();
         }
-        occurrences_lc = occurrences_lc + bit.lc(CS::one(), value_fp);
+        // If we're in setup mode, we skip the bit counting part since the bitmap
+        // will be empty
+        let is_setup = is_setup(self);
+
+        let mut occurrences = 0;
+        let mut occurrences_lc = LinearCombination::zero();
+        // For each bit, increment the number of occurences if the bit matched `value`
+        // We calculate both the number of occurrences
+        // and a linear combination over it, in order to do 2 things:
+        // 1. enforce that occurrences < maximum_occurences
+        // 2. enforce that occurrences was calculated correctly from the bitmap
+        for bit in self {
+            // Update the constraints
+            if !value {
+                // add 1 here only for zeros
+                occurrences_lc += (F::one(), Variable::One);
+            }
+            occurrences_lc = occurrences_lc + bit.lc() * value_fp;
 
-        // Update our count
-        if !is_setup {
-            let got_value = bit.get_value().get()?;
-            occurrences += (got_value == value) as u8;
+            // Update our count
+            if !is_setup {
+                let got_value = bit.value()?;
+                occurrences += (got_value == value) as u8;
+            }
         }
-    }
 
-    // Rebind `occurrences` to a constraint
-    let occurrences = FpGadget::alloc(&mut cs.ns(|| "num occurrences"), || {
-        Ok(F::from(occurrences))
-    })?;
-
-    // Enforce `occurences <= max_occurences`
-    occurrences.enforce_cmp(
-        &mut cs.ns(|| "enforce maximum number of occurrences"),
-        &max_occurrences,
-        std::cmp::Ordering::Less,
-        true,
-    )?;
-
-    // Enforce that we have correctly counted the number of occurrences
-    cs.enforce(
-        || "enforce num occurrences lc equal to num",
-        |_| occurrences_lc,
-        |lc| lc + (F::one(), CS::one()),
-        |lc| occurrences.get_variable() + lc,
-    );
-
-    Ok(())
+        // Rebind `occurrences` to a constraint
+        let occurrences = FpVar::new_witness(self.cs().unwrap_or(ConstraintSystemRef::None),
+            || { Ok(F::from(occurrences)) }
+        )?;
+
+        // Enforce `occurences <= max_occurences`
+        occurrences.enforce_cmp(
+            &max_occurrences,
+            std::cmp::Ordering::Less,
+            true,
+        )?;
+
+        let occurrences_var = match occurrences {
+            FpVar::Var(v) => v,
+            _ => unreachable!(),
+        };
+        // Enforce that we have correctly counted the number of occurrences
+        self.cs().unwrap_or(ConstraintSystemRef::None).enforce_constraint(
+            occurrences_lc,
+            lc!() + (F::one(), Variable::One),
+            lc!() + occurrences_var.variable,
+        )?;
+
+        Ok(())
+    }
 }
 
+
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -81,7 +93,7 @@ mod tests {
         create_random_proof, generate_random_parameters, prepare_verifying_key, verify_proof,
     };
     use r1cs_core::ConstraintSynthesizer;
-    use r1cs_std::test_constraint_system::TestConstraintSystem;
+    use std::assert;
 
     #[test]
     // "I know of a bitmap that has at most 2 zeros"
@@ -96,23 +108,23 @@ mod tests {
         }
 
         impl ConstraintSynthesizer<Fr> for BitmapGadget {
-            fn generate_constraints<CS: ConstraintSystem<Fr>>(
+            fn generate_constraints(
                 self,
-                cs: &mut CS,
+                cs: ConstraintSystemRef<Fr>,
             ) -> Result<(), SynthesisError> {
                 let bitmap = self
                     .bitmap
                     .iter()
                     .enumerate()
                     .map(|(i, b)| {
-                        Boolean::alloc(cs.ns(|| i.to_string()), || Ok(b.unwrap())).unwrap()
+                        Boolean::new_witness(cs.clone(), || Ok(b.unwrap())).unwrap()
                     })
                     .collect::<Vec<_>>();
-                let max_occurrences = FpGadget::<Fr>::alloc(cs.ns(|| "max occurences"), || {
+                let max_occurrences = FpVar::<Fr>::new_witness(cs.clone(), || {
                     Ok(Fr::from(self.max_occurrences))
                 })
                 .unwrap();
-                enforce_maximum_occurrences_in_bitmap(cs, &bitmap, &max_occurrences, self.value)
+                bitmap.enforce_maximum_occurrences_in_bitmap(&max_occurrences, self.value)
             }
         }
 
@@ -135,9 +147,9 @@ mod tests {
 
         // since our Test constraint system is satisfied, the groth16 proof
         // should also work
-        let mut cs = TestConstraintSystem::<Fr>::new();
-        circuit.clone().generate_constraints(&mut cs).unwrap();
-        assert!(cs.is_satisfied());
+        let mut cs = ConstraintSystem::<Fr>::new_ref();
+        circuit.clone().generate_constraints(cs.clone()).unwrap();
+        assert!(cs.is_satisfied().unwrap());
         let proof = create_random_proof(circuit, &params, rng).unwrap();
 
         let pvk = prepare_verifying_key(&params.vk);
@@ -148,15 +160,15 @@ mod tests {
         bitmap: &[bool],
         max_number: u64,
         is_one: bool,
-    ) -> TestConstraintSystem<Fq> {
-        let mut cs = TestConstraintSystem::<Fq>::new();
+    ) -> ConstraintSystemRef<Fq> {
+        let mut cs = ConstraintSystem::<Fq>::new_ref();
         let bitmap = bitmap
             .iter()
-            .map(|b| Boolean::constant(*b))
+            .map(|b| Boolean::new_witness(cs.clone(), || Ok(*b)).unwrap())
             .collect::<Vec<_>>();
         let max_occurrences =
-            FpGadget::<Fq>::alloc(cs.ns(|| "max occurences"), || Ok(Fq::from(max_number))).unwrap();
-        enforce_maximum_occurrences_in_bitmap(&mut cs, &bitmap, &max_occurrences, is_one).unwrap();
+            FpVar::<Fq>::new_witness(cs.clone(), || Ok(Fq::from(max_number))).unwrap();
+        bitmap[..].enforce_maximum_occurrences_in_bitmap(&max_occurrences, is_one).unwrap();
         cs
     }
 
@@ -165,23 +177,24 @@ mod tests {
 
         #[test]
         fn one_zero_allowed() {
-            assert!(cs_enforce_value(&[false], 1, false).is_satisfied());
+            assert!(cs_enforce_value(&[false], 1, false).is_satisfied().unwrap());
         }
 
         #[test]
         fn no_zeros_allowed() {
-            assert!(!cs_enforce_value(&[false], 0, false).is_satisfied());
+            assert!(!cs_enforce_value(&[false], 0, false).is_satisfied().unwrap());
         }
 
         #[test]
+
         fn three_zeros_allowed() {
-            assert!(cs_enforce_value(&[false, true, true, false, false], 3, false).is_satisfied());
+            assert!(cs_enforce_value(&[false, true, true, false, false], 3, false).is_satisfied().unwrap());
         }
 
         #[test]
         fn four_zeros_not_allowed() {
             assert!(
-                !cs_enforce_value(&[false, false, true, false, false], 3, false).is_satisfied()
+                !cs_enforce_value(&[false, false, true, false, false], 3, false).is_satisfied().unwrap()
             );
         }
     }
@@ -191,22 +204,22 @@ mod tests {
 
         #[test]
         fn one_one_allowed() {
-            assert!(cs_enforce_value(&[true], 1, true).is_satisfied());
+            assert!(cs_enforce_value(&[true], 1, true).is_satisfied().unwrap());
         }
 
         #[test]
         fn no_ones_allowed() {
-            assert!(!cs_enforce_value(&[true], 0, true).is_satisfied());
+            assert!(!cs_enforce_value(&[true], 0, true).is_satisfied().unwrap());
         }
 
         #[test]
         fn three_ones_allowed() {
-            assert!(cs_enforce_value(&[false, true, true, true, false], 3, true).is_satisfied());
+            assert!(cs_enforce_value(&[false, true, true, true, false], 3, true).is_satisfied().unwrap());
         }
 
         #[test]
         fn four_ones_not_allowed() {
-            assert!(!cs_enforce_value(&[true, true, true, true, false], 3, true).is_satisfied());
+            assert!(!cs_enforce_value(&[true, true, true, true, false], 3, true).is_satisfied().unwrap());
         }
     }
 }
diff --git a/crates/bls-gadgets/src/bls.rs b/crates/bls-gadgets/src/bls.rs
index dc1dcff..7f38e49 100644
--- a/crates/bls-gadgets/src/bls.rs
+++ b/crates/bls-gadgets/src/bls.rs
@@ -1,11 +1,12 @@
-use crate::enforce_maximum_occurrences_in_bitmap;
+use crate::Bitmap;
 use algebra::{PairingEngine, PrimeField, ProjectiveCurve};
-use r1cs_core::{ConstraintSystem, SynthesisError};
+use r1cs_core::{SynthesisError, ConstraintSystemRef};
 use r1cs_std::{
-    alloc::AllocGadget, boolean::Boolean, eq::EqGadget, fields::fp::FpGadget, fields::FieldGadget,
-    groups::GroupGadget, pairing::PairingGadget, select::CondSelectGadget,
+    boolean::Boolean, eq::EqGadget, fields::fp::FpVar, fields::FieldVar, R1CSVar,
+    groups::CurveVar, pairing::PairingVar, alloc::AllocVar,
 };
 use std::marker::PhantomData;
+use std::ops::AddAssign;
 use tracing::{debug, span, trace, Level};
 
 /// BLS Signature Verification Gadget.
@@ -25,7 +26,8 @@ impl<E, F, P> BlsVerifyGadget<E, F, P>
 where
     E: PairingEngine,
     F: PrimeField,
-    P: PairingGadget<E, F>,
+    P: PairingVar<E, F>,
+    P::G2Var: for<'a> AddAssign<&'a P::G2Var>,
 {
     /// Enforces verification of a BLS Signature against a list of public keys and a bitmap indicating
     /// which of these pubkeys signed.
@@ -35,20 +37,18 @@ where
     ///
     /// The verification equation can be found in pg.11 from
     /// https://eprint.iacr.org/2018/483.pdf: "Multi-Signature Verification"
-    pub fn verify<CS: ConstraintSystem<F>>(
-        mut cs: CS,
-        pub_keys: &[P::G2Gadget],
-        signed_bitmap: &[Boolean],
-        message_hash: &P::G1Gadget,
-        signature: &P::G1Gadget,
-        maximum_non_signers: &FpGadget<F>,
+    pub fn verify(
+        pub_keys: &[P::G2Var],
+        signed_bitmap: &[Boolean<F>],
+        message_hash: &P::G1Var,
+        signature: &P::G1Var,
+        maximum_non_signers: &FpVar<F>,
     ) -> Result<(), SynthesisError> {
         let span = span!(Level::TRACE, "BlsVerifyGadget_verify");
         let _enter = span.enter();
         // Get the message hash and the aggregated public key based on the bitmap
         // and allowed number of non-signers
         let (message_hash, aggregated_pk) = Self::enforce_bitmap(
-            cs.ns(|| "verify partial"),
             pub_keys,
             signed_bitmap,
             message_hash,
@@ -56,18 +56,17 @@ where
         )?;
 
         let prepared_aggregated_pk =
-            P::prepare_g2(cs.ns(|| "prepare aggregate pk in epoch"), &aggregated_pk)?;
+            P::prepare_g2(&aggregated_pk)?;
 
         let prepared_message_hash =
-            P::prepare_g1(cs.ns(|| "prepare message hash in epoch"), &message_hash)?;
+            P::prepare_g1(&message_hash)?;
 
         // Prepare the signature and get the generator
         let (prepared_signature, prepared_g2_neg_generator) =
-            Self::prepare_signature_neg_generator(&mut cs, &signature)?;
+            Self::prepare_signature_neg_generator(&signature)?;
 
         // e(σ, g_2^-1) * e(H(m), apk) == 1_{G_T}
         Self::enforce_bls_equation(
-            &mut cs,
             &[prepared_signature, prepared_message_hash],
             &[prepared_g2_neg_generator, prepared_aggregated_pk],
         )?;
@@ -80,19 +79,17 @@ where
     ///
     /// The verification equation can be found in pg.11 from
     /// https://eprint.iacr.org/2018/483.pdf: "Batch verification"
-    pub fn batch_verify<CS: ConstraintSystem<F>>(
-        mut cs: CS,
-        aggregated_pub_keys: &[P::G2Gadget],
-        message_hashes: &[P::G1Gadget],
-        aggregated_signature: &P::G1Gadget,
+    pub fn batch_verify(
+        aggregated_pub_keys: &[P::G2Var],
+        message_hashes: &[P::G1Var],
+        aggregated_signature: &P::G1Var,
     ) -> Result<(), SynthesisError> {
         debug!("batch verifying BLS signature");
         let prepared_message_hashes = message_hashes
             .iter()
             .enumerate()
-            .map(|(i, message_hash)| {
+            .map(|(_i, message_hash)| {
                 P::prepare_g1(
-                    cs.ns(|| format!("prepared message hash {}", i)),
                     &message_hash,
                 )
             })
@@ -100,11 +97,10 @@ where
         let prepared_aggregated_pub_keys = aggregated_pub_keys
             .iter()
             .enumerate()
-            .map(|(i, pubkey)| P::prepare_g2(cs.ns(|| format!("prepared pubkey {}", i)), &pubkey))
+            .map(|(_i, pubkey)| P::prepare_g2(&pubkey))
             .collect::<Result<Vec<_>, _>>()?;
 
         Self::batch_verify_prepared(
-            cs,
             &prepared_aggregated_pub_keys,
             &prepared_message_hashes,
             aggregated_signature,
@@ -112,15 +108,14 @@ where
     }
 
     /// Batch verification against prepared messages
-    pub fn batch_verify_prepared<CS: ConstraintSystem<F>>(
-        mut cs: CS,
-        prepared_aggregated_pub_keys: &[P::G2PreparedGadget],
-        prepared_message_hashes: &[P::G1PreparedGadget],
-        aggregated_signature: &P::G1Gadget,
+    pub fn batch_verify_prepared(
+        prepared_aggregated_pub_keys: &[P::G2PreparedVar],
+        prepared_message_hashes: &[P::G1PreparedVar],
+        aggregated_signature: &P::G1Var,
     ) -> Result<(), SynthesisError> {
         // Prepare the signature and get the generator
         let (prepared_signature, prepared_g2_neg_generator) =
-            Self::prepare_signature_neg_generator(&mut cs, aggregated_signature)?;
+            Self::prepare_signature_neg_generator(aggregated_signature)?;
 
         // Create the vectors which we'll batch verify
         let mut prepared_g1s = vec![prepared_signature];
@@ -130,7 +125,7 @@ where
 
         // Enforce the BLS check
         // e(σ, g_2^-1) * e(H(m0), pk_0) * e(H(m1), pk_1) ...  * e(H(m_n), pk_n)) == 1_{G_T}
-        Self::enforce_bls_equation(&mut cs, &prepared_g1s, &prepared_g2s)?;
+        Self::enforce_bls_equation(&prepared_g1s, &prepared_g2s)?;
 
         Ok(())
     }
@@ -140,67 +135,34 @@ where
     ///
     /// # Panics
     /// If signed_bitmap length != pub_keys length
-    pub fn enforce_aggregated_pubkeys<CS: ConstraintSystem<F>>(
-        mut cs: CS,
-        pub_keys: &[P::G2Gadget],
-        signed_bitmap: &[Boolean],
-    ) -> Result<P::G2Gadget, SynthesisError> {
+    pub fn enforce_aggregated_pubkeys(
+        pub_keys: &[P::G2Var],
+        signed_bitmap: &[Boolean<F>],
+    ) -> Result<P::G2Var, SynthesisError> {
         // Bitmap and Pubkeys must be of the same length
         assert_eq!(signed_bitmap.len(), pub_keys.len());
-        // Allocate the G2 Generator
-        let g2_generator = P::G2Gadget::alloc_constant(
-            cs.ns(|| "G2 generator"),
-            E::G2Projective::prime_subgroup_generator(),
-        )?;
 
-        // We initialize the Aggregate Public Key as a generator point, in order to
-        // calculate the sum of all keys which have signed according to the bitmap.
-        // This is needed since we cannot add to a Zero.
-        // After the sum is calculated, we must subtract the generator to get the
-        // correct result
-        let mut aggregated_pk = g2_generator.clone();
-        for (i, (pk, bit)) in pub_keys.iter().zip(signed_bitmap).enumerate() {
-            // Add the pubkey to the sum
-            // if bit: aggregated_pk += pk
-            let added = aggregated_pk.add(cs.ns(|| format!("add pk {}", i)), pk)?;
-            aggregated_pk = P::G2Gadget::conditionally_select(
-                &mut cs.ns(|| format!("cond_select {}", i)),
-                &bit,
-                &added,
-                &aggregated_pk,
-            )?;
+        let mut aggregated_pk = P::G2Var::zero();
+        for (_i, (pk, bit)) in pub_keys.iter().zip(signed_bitmap).enumerate() {
+            // If bit = 1, add pk
+            let adder = bit.select(pk, &P::G2Var::zero())?;
+            aggregated_pk += &adder;
         }
-        // Subtract the generator to get the correct aggregate pubkey
-        aggregated_pk = aggregated_pk.sub(cs.ns(|| "add neg generator"), &g2_generator)?;
 
         Ok(aggregated_pk)
     }
 
     /// Returns a gadget which checks that an aggregate pubkey is correctly calculated
     /// by the sum of the pub keys
-    pub fn enforce_aggregated_all_pubkeys<CS: ConstraintSystem<F>>(
-        mut cs: CS,
-        pub_keys: &[P::G2Gadget],
-    ) -> Result<P::G2Gadget, SynthesisError> {
-        // Allocate the G2 Generator
-        let g2_generator = P::G2Gadget::alloc_constant(
-            cs.ns(|| "G2 generator"),
-            E::G2Projective::prime_subgroup_generator(),
-        )?;
-
-        // We initialize the Aggregate Public Key as a generator point, in order to
-        // calculate the sum of all keys.
-        // This is needed since we cannot add to a Zero.
-        // After the sum is calculated, we must subtract the generator to get the
-        // correct result
-        let mut aggregated_pk = g2_generator.clone();
-        for (i, pk) in pub_keys.iter().enumerate() {
+    pub fn enforce_aggregated_all_pubkeys(
+        pub_keys: &[P::G2Var],
+    ) -> Result<P::G2Var, SynthesisError> {
+        let mut aggregated_pk = P::G2Var::zero();
+        for (_i, pk) in pub_keys.iter().enumerate() {
             // Add the pubkey to the sum
             // aggregated_pk += pk
-            aggregated_pk = aggregated_pk.add(&mut cs.ns(|| format!("add pk {}", i)), pk)?;
+            aggregated_pk += pk; 
         }
-        // Subtract the generator to get the correct aggregate pubkey
-        aggregated_pk = aggregated_pk.sub(cs.ns(|| "add neg generator"), &g2_generator)?;
 
         Ok(aggregated_pk)
     }
@@ -210,39 +172,37 @@ where
     ///
     /// # Panics
     /// If signed_bitmap length != pub_keys length (due to internal call to `enforced_aggregated_pubkeys`)
-    pub fn enforce_bitmap<CS: ConstraintSystem<F>>(
-        mut cs: CS,
-        pub_keys: &[P::G2Gadget],
-        signed_bitmap: &[Boolean],
-        message_hash: &P::G1Gadget,
-        maximum_non_signers: &FpGadget<F>,
-    ) -> Result<(P::G1Gadget, P::G2Gadget), SynthesisError> {
+    pub fn enforce_bitmap(
+        pub_keys: &[P::G2Var],
+        signed_bitmap: &[Boolean<F>],
+        message_hash: &P::G1Var,
+        maximum_non_signers: &FpVar<F>,
+    ) -> Result<(P::G1Var, P::G2Var), SynthesisError> {
         trace!("enforcing bitmap");
-        enforce_maximum_occurrences_in_bitmap(&mut cs, signed_bitmap, maximum_non_signers, false)?;
+        signed_bitmap.enforce_maximum_occurrences_in_bitmap(maximum_non_signers, false)?;
 
-        let aggregated_pk = Self::enforce_aggregated_pubkeys(&mut cs, pub_keys, signed_bitmap)?;
+        let aggregated_pk = Self::enforce_aggregated_pubkeys(pub_keys, signed_bitmap)?;
 
         Ok((message_hash.clone(), aggregated_pk))
     }
 
     /// Verifying BLS signatures requires preparing a G1 Signature and
     /// preparing a negated G2 generator
-    fn prepare_signature_neg_generator<CS: ConstraintSystem<F>>(
-        cs: &mut CS,
-        signature: &P::G1Gadget,
-    ) -> Result<(P::G1PreparedGadget, P::G2PreparedGadget), SynthesisError> {
+    fn prepare_signature_neg_generator(
+        signature: &P::G1Var,
+    ) -> Result<(P::G1PreparedVar, P::G2PreparedVar), SynthesisError> {
         // Ensure the signature is prepared
-        let prepared_signature = P::prepare_g1(cs.ns(|| "prepared signature"), signature)?;
+        let prepared_signature = P::prepare_g1(signature)?;
 
         // Allocate the generator on G2
-        let g2_generator = P::G2Gadget::alloc_constant(
-            cs.ns(|| "G2 generator"),
+        let g2_generator = <P::G2Var as AllocVar<E::G2Projective,F>>::new_constant(
+            signature.cs().unwrap_or(ConstraintSystemRef::None),
             E::G2Projective::prime_subgroup_generator(),
         )?;
         // and negate it for the purpose of verification
-        let g2_neg_generator = g2_generator.negate(cs.ns(|| "negate g2 generator"))?;
+        let g2_neg_generator = g2_generator.negate()?;
         let prepared_g2_neg_generator =
-            P::prepare_g2(cs.ns(|| "prepared g2 neg generator"), &g2_neg_generator)?;
+            P::prepare_g2(&g2_neg_generator)?;
 
         Ok((prepared_signature, prepared_g2_neg_generator))
     }
@@ -252,15 +212,14 @@ where
     ///
     /// Each G1 element is paired with the corresponding G2 element.
     /// Fails if the 2 slices have different lengths.
-    fn enforce_bls_equation<CS: ConstraintSystem<F>>(
-        cs: &mut CS,
-        g1: &[P::G1PreparedGadget],
-        g2: &[P::G2PreparedGadget],
+    fn enforce_bls_equation(
+        g1: &[P::G1PreparedVar],
+        g2: &[P::G2PreparedVar],
     ) -> Result<(), SynthesisError> {
         trace!("enforcing BLS equation");
-        let bls_equation = P::product_of_pairings(cs.ns(|| "verify BLS signature"), g1, g2)?;
-        let gt_one = &P::GTGadget::one(&mut cs.ns(|| "GT one"))?;
-        bls_equation.enforce_equal(&mut cs.ns(|| "BLS equation is one"), gt_one)?;
+        let bls_equation = P::product_of_pairings(g1, g2)?;
+        let gt_one = &P::GTVar::one();
+        bls_equation.enforce_equal(gt_one)?;
         Ok(())
     }
 }
@@ -268,55 +227,54 @@ where
 #[cfg(test)]
 mod verify_one_message {
     use super::*;
-    use crate::utils::test_helpers::alloc_vec;
+//    use crate::utils::test_helpers::alloc_vec;
     use bls_crypto::test_helpers::*;
 
     use algebra::{
-        bls12_377::{Bls12_377, Fr as Bls12_377Fr, G1Projective, G2Projective},
+        bls12_377::{Bls12_377, Fr as Bls12_377Fr, G1Projective, G2Projective, Parameters as Bls12_377_Parameters},
         bw6_761::Fr as BW6_761Fr,
         ProjectiveCurve, UniformRand, Zero,
     };
     use r1cs_core::ConstraintSystem;
     use r1cs_std::{
-        alloc::AllocGadget,
-        bls12_377::{G1Gadget, PairingGadget as Bls12_377PairingGadget},
+        alloc::AllocVar,
+        bls12_377::{G1Var, G2Var, PairingVar as Bls12_377PairingGadget},
         boolean::Boolean,
-        test_constraint_system::TestConstraintSystem,
+//        test_constraint_system::TestConstraintSystem,
     };
 
     // converts the arguments to constraints and checks them against the `verify` function
-    fn cs_verify<E: PairingEngine, F: PrimeField, P: PairingGadget<E, F>>(
+    fn cs_verify<E: PairingEngine, F: PrimeField, P: PairingVar<E, F>>(
         message_hash: E::G1Projective,
         pub_keys: &[E::G2Projective],
         signature: E::G1Projective,
         bitmap: &[bool],
         num_non_signers: u64,
-    ) -> TestConstraintSystem<F> {
-        let mut cs = TestConstraintSystem::<F>::new();
+    ) -> ConstraintSystemRef<F> {
+        let mut cs = ConstraintSystem::<F>::new_ref();
 
         let message_hash_var =
-            P::G1Gadget::alloc(cs.ns(|| "message_hash"), || Ok(message_hash)).unwrap();
-        let signature_var = P::G1Gadget::alloc(cs.ns(|| "signature"), || Ok(signature)).unwrap();
+            <P::G1Var as AllocVar<E::G1Projective, _>>::new_witness(cs.clone(), || Ok(message_hash)).unwrap();
+        let signature_var = <P::G1Var as AllocVar<E::G1Projective, _>>::new_witness(cs.clone(), || Ok(signature)).unwrap();
 
         let pub_keys = pub_keys
             .iter()
             .enumerate()
             .map(|(i, pub_key)| {
-                P::G2Gadget::alloc(cs.ns(|| format!("pub_key_{}", i)), || Ok(pub_key)).unwrap()
+                <P::G2Var as AllocVar<E::G2Projective, _>>::new_witness(cs.clone(), || Ok(pub_key)).unwrap()
             })
             .collect::<Vec<_>>();
         let bitmap = bitmap
             .iter()
-            .map(|b| Boolean::constant(*b))
+            .map(|b| Boolean::new_witness(cs.clone(), || Ok(*b)).unwrap())
             .collect::<Vec<_>>();
 
         let max_occurrences =
-            &FpGadget::<F>::alloc(cs.ns(|| "num non signers"), || Ok(F::from(num_non_signers)))
+            &FpVar::<F>::new_witness(cs.clone(), || Ok(F::from(num_non_signers)))
                 .unwrap();
         BlsVerifyGadget::<E, F, P>::verify(
-            cs.ns(|| "verify sig"),
             &pub_keys,
-            &bitmap,
+            &bitmap[..],
             &message_hash_var,
             &signature_var,
             &max_occurrences,
@@ -351,20 +309,19 @@ mod verify_one_message {
         let asig = sum(&asigs);
 
         // allocate the constraints
-        let mut cs = TestConstraintSystem::<BW6_761Fr>::new();
-        let messages = alloc_vec(&mut cs.ns(|| "messages"), &messages);
-        let aggregate_pubkeys = alloc_vec(&mut cs.ns(|| "aggregate pubkeys"), &aggregate_pubkeys);
-        let asig = G1Gadget::alloc(&mut cs.ns(|| "asig"), || Ok(asig)).unwrap();
+        let mut cs = ConstraintSystem::<BW6_761Fr>::new_ref();
+        let messages = messages.iter().enumerate().map(|(i, element)| <G1Var as AllocVar<G1Projective, _>>::new_witness(cs.clone(), || Ok(element)).unwrap()).collect::<Vec<_>>(); //alloc_vec(cs.clone(), &messages);
+        let aggregate_pubkeys = aggregate_pubkeys.iter().enumerate().map(|(i, element)| <G2Var as AllocVar<G2Projective, _>>::new_witness(cs.clone(), || Ok(element)).unwrap()).collect::<Vec<_>>(); //alloc_vec(cs.clone(), &aggregate_pubkeys);
+        let asig = G1Var::new_witness(cs.clone(), || Ok(asig)).unwrap();
 
         // check that verification is correct
         BlsVerifyGadget::<Bls12_377, BW6_761Fr, Bls12_377PairingGadget>::batch_verify(
-            &mut cs,
             &aggregate_pubkeys,
             &messages,
             &asig,
         )
         .unwrap();
-        assert!(cs.is_satisfied());
+        assert!(cs.is_satisfied().unwrap());
     }
 
     #[test]
@@ -384,8 +341,8 @@ mod verify_one_message {
             &[true],
             0,
         );
-        assert!(cs.is_satisfied());
-        assert_eq!(cs.num_constraints(), 21184);
+        assert!(cs.is_satisfied().unwrap());
+        //assert_eq!(cs.num_constraints(), 21184);
 
         // random sig fails
         let cs = cs_verify::<Bls12_377, BW6_761Fr, Bls12_377PairingGadget>(
@@ -395,7 +352,7 @@ mod verify_one_message {
             &[true],
             0,
         );
-        assert!(!cs.is_satisfied());
+        assert!(!cs.is_satisfied().unwrap());
     }
 
     #[test]
@@ -414,7 +371,7 @@ mod verify_one_message {
             &[true, true],
             1,
         );
-        assert!(cs.is_satisfied());
+        assert!(cs.is_satisfied().unwrap());
 
         // using the single sig if second guy is OK as long as
         // we tolerate 1 non-signers
@@ -425,7 +382,7 @@ mod verify_one_message {
             &[true, false],
             1,
         );
-        assert!(cs.is_satisfied());
+        assert!(cs.is_satisfied().unwrap());
 
         // bitmap set to false on the second one fails since we don't tolerate
         // >0 failures
@@ -436,7 +393,7 @@ mod verify_one_message {
             &[true, false],
             0,
         );
-        assert!(!cs.is_satisfied());
+        assert!(!cs.is_satisfied().unwrap());
         let cs = cs_verify::<Bls12_377, BW6_761Fr, Bls12_377PairingGadget>(
             message_hash,
             &[pk, pk2],
@@ -444,7 +401,7 @@ mod verify_one_message {
             &[true, false],
             0,
         );
-        assert!(!cs.is_satisfied());
+        assert!(!cs.is_satisfied().unwrap());
     }
 
     #[test]
@@ -468,6 +425,6 @@ mod verify_one_message {
             &[false, true],
             3,
         );
-        assert!(!cs.is_satisfied());
+        assert!(!cs.is_satisfied().unwrap());
     }
 }
diff --git a/crates/bls-gadgets/src/hash_to_group.rs b/crates/bls-gadgets/src/hash_to_group.rs
index c468c00..fe117d2 100644
--- a/crates/bls-gadgets/src/hash_to_group.rs
+++ b/crates/bls-gadgets/src/hash_to_group.rs
@@ -1,5 +1,5 @@
 use crate::{
-    utils::{bits_to_bytes, bytes_to_bits, constrain_bool, is_setup},
+    utils::{bits_to_bytes, bytes_to_bits, is_setup},
     YToBitGadget,
 };
 use bls_crypto::{
@@ -9,37 +9,38 @@ use bls_crypto::{
     },
     SIG_DOMAIN,
 };
-
+use r1cs_std::alloc::AllocVar;
+use r1cs_std::alloc::AllocationMode;
+use std::ops::Sub;
 // Imported for the BLS12-377 API
 use algebra::{
     bls12_377::{Fq as Bls12_377_Fq, Parameters as Bls12_377_Parameters},
-    ed_on_bw6_761::EdwardsProjective,
 };
+use tracing_subscriber::layer::SubscriberExt;
+
 use algebra::{
     curves::{
-        bls12::G1Projective,
+        bls12::{G1Affine, G1Projective},
         models::bls12::Bls12Parameters,
         short_weierstrass_jacobian::{GroupAffine, GroupProjective},
         SWModelParameters,
     },
-    AffineCurve, BigInteger, BitIterator, One, PrimeField, ProjectiveCurve,
+    AffineCurve, BigInteger, BitIteratorBE, PrimeField, ProjectiveCurve,
 };
 use crypto_primitives::{
     crh::{
-        bowe_hopwood::constraints::BoweHopwoodPedersenCRHGadget as BHHash, FixedLengthCRHGadget,
+        bowe_hopwood::constraints::CRHGadget as BHHash, FixedLengthCRHGadget
     },
-    prf::{blake2s::constraints::blake2s_gadget_with_parameters, Blake2sWithParameterBlock},
+    prf::{blake2s::constraints::evaluate_blake2s_with_parameters, Blake2sWithParameterBlock},
 };
-use r1cs_core::{ConstraintSystem, SynthesisError};
+use r1cs_core::{SynthesisError, ConstraintSystemRef, ConstraintLayer};
 use r1cs_std::{
-    alloc::AllocGadget, bits::ToBitsGadget, boolean::Boolean, ed_on_cp6_782::EdwardsGadget,
-    groups::bls12::G1Gadget, groups::GroupGadget, uint8::UInt8, Assignment,
+    bits::ToBitsGadget, boolean::Boolean,
+    groups::bls12::G1Var, groups::CurveVar, uint8::UInt8, Assignment, R1CSVar, eq::EqGadget
 };
 use std::{borrow::Borrow, marker::PhantomData};
 use tracing::{debug, span, trace, Level};
-
-/// Pedersen Gadget instantiated over the Edwards BW6_761 curve over BLS12-377 Fq (384 bits)
-type BHHashBW6_761 = BHHash<EdwardsProjective, Bls12_377_Fq, EdwardsGadget>;
+use algebra::ed_on_bw6_761::EdwardsParameters;
 
 // The deployed Celo version's hash-to-curve takes the sign bit from position 377.
 #[cfg(feature = "compat")]
@@ -86,14 +87,15 @@ fn blake2xs_params(
 /// Currently this gadget only exposes hashing to BLS12-377's G1.
 ///
 /// [hash_to_group]: ../bls_crypto/hash_to_curve/try_and_increment/index.html
-pub struct HashToGroupGadget<P> {
+pub struct HashToGroupGadget<P, F: PrimeField> {
     parameters_type: PhantomData<P>,
+    field_type: PhantomData<F>,
 }
 
 // If we're on Bls12-377, we can have a nice public API for the whole hash to group operation
 // by taking the input, compressing it via an instantiation of Pedersen Hash with a CRH over Edwards BW6_761
 // and then hashing it to bits and to group
-impl HashToGroupGadget<Bls12_377_Parameters> {
+impl HashToGroupGadget<Bls12_377_Parameters, Bls12_377_Fq> {
     /// Returns the G1 constrained hash of the message with the provided counter.
     ///
     /// If `generate_constraints_for_hash` is set to `false`, then constraints will not
@@ -105,12 +107,11 @@ impl HashToGroupGadget<Bls12_377_Parameters> {
     /// so that they can be used to verify the correct calculation of the XOF from
     /// the CRH in a separate proof.
     #[allow(clippy::type_complexity)]
-    pub fn enforce_hash_to_group<CS: ConstraintSystem<Bls12_377_Fq>>(
-        cs: &mut CS,
-        counter: UInt8,
-        message: &[UInt8],
+    pub fn enforce_hash_to_group(
+        counter: UInt8<Bls12_377_Fq>,
+        message: &[UInt8<Bls12_377_Fq>],
         generate_constraints_for_hash: bool,
-    ) -> Result<(G1Gadget<Bls12_377_Parameters>, Vec<Boolean>, Vec<Boolean>), SynthesisError> {
+    ) -> Result<(G1Var<Bls12_377_Parameters>, Vec<Boolean<Bls12_377_Fq>>, Vec<Boolean<Bls12_377_Fq>>), SynthesisError> {
         let span = span!(Level::TRACE, "enforce_hash_to_group",);
         let _enter = span.enter();
 
@@ -118,7 +119,9 @@ impl HashToGroupGadget<Bls12_377_Parameters> {
         let mut input = vec![counter];
         input.extend_from_slice(message);
         // compress the input
-        let crh_bits = Self::pedersen_hash(cs, &input)?;
+        println!("gadget pedersen input: {:?}", message);
+        let crh_bits = Self::pedersen_hash(&input)?;
+        println!("crh_bits gadget: {:?}", crh_bits.value()?);
 
         // Hash to bits
         let mut personalization = [0; 8];
@@ -126,40 +129,38 @@ impl HashToGroupGadget<Bls12_377_Parameters> {
         // We want 378 random bits for hashing to curve, so we get 512 from the hash and will
         // discard any unneeded ones. We do not generate constraints.
         let xof_bits = hash_to_bits(
-            cs.ns(|| "hash to bits"),
             &crh_bits,
             512,
             personalization,
             generate_constraints_for_hash,
         )?;
+        println!("xof_bits gadget: {:?}", xof_bits.value()?); 
 
-        let hash = Self::hash_to_group(cs.ns(|| "hash to group"), &xof_bits)?;
+        let hash = Self::hash_to_group(&xof_bits)?;
 
         debug!("message and counter have been hashed to G1");
         Ok((hash, crh_bits, xof_bits))
     }
 
     /// Compress the input by passing it through a Pedersen hash
-    fn pedersen_hash<CS: ConstraintSystem<Bls12_377_Fq>>(
-        cs: &mut CS,
-        input: &[UInt8],
-    ) -> Result<Vec<Boolean>, SynthesisError> {
+    fn pedersen_hash(
+        input: &[UInt8<Bls12_377_Fq>],
+    ) -> Result<Vec<Boolean<Bls12_377_Fq>>, SynthesisError> {
         // We setup by getting the Parameters over the provided CRH
         let crh_params =
-            <BHHashBW6_761 as FixedLengthCRHGadget<CRH, _>>::ParametersGadget::alloc_constant(
-                cs.ns(|| "pedersen parameters"),
+            <BHHash<EdwardsParameters, _> as FixedLengthCRHGadget<CRH, _>>::ParametersVar::new_constant(
+                input.cs().unwrap_or(ConstraintSystemRef::None),
                 CompositeHasher::<CRH>::setup_crh()
                     .map_err(|_| SynthesisError::AssignmentMissing)?,
             )?;
 
         let pedersen_hash =
-            <BHHashBW6_761 as FixedLengthCRHGadget<CRH, _>>::check_evaluation_gadget(
-                &mut cs.ns(|| "pedersen evaluation"),
+            <BHHash<EdwardsParameters, _> as FixedLengthCRHGadget<CRH, _>>::evaluate(
                 &crh_params,
                 &input,
             )?;
 
-        let mut crh_bits = pedersen_hash.x.to_bits(cs.ns(|| "crh bits")).unwrap();
+        let mut crh_bits = pedersen_hash.x.to_bits_le().unwrap();
         // The hash must be front-padded to the nearest multiple of 8 for the LE encoding
         loop {
             if crh_bits.len() % 8 == 0 {
@@ -182,13 +183,13 @@ impl HashToGroupGadget<Bls12_377_Parameters> {
 /// # Panics
 ///
 /// If the provided hash_length is not a multiple of 256.
-pub fn hash_to_bits<F: PrimeField, CS: ConstraintSystem<F>>(
-    mut cs: CS,
-    message: &[Boolean],
+#[tracing::instrument(target = "r1cs")]
+pub fn hash_to_bits<F: PrimeField>(
+    message: &[Boolean<F>],
     hash_length: u16,
     personalization: [u8; 8],
     generate_constraints_for_hash: bool,
-) -> Result<Vec<Boolean>, SynthesisError> {
+) -> Result<Vec<Boolean<F>>, SynthesisError> {
     let span = span!(
         Level::TRACE,
         "hash_to_bits",
@@ -212,8 +213,7 @@ pub fn hash_to_bits<F: PrimeField, CS: ConstraintSystem<F>>(
             trace!(blake_iteration = i);
             // calculate the hash (Vec<Boolean>)
             let blake2s_parameters = blake2xs_params(hash_length, i.into(), personalization);
-            let xof_result = blake2s_gadget_with_parameters(
-                cs.ns(|| format!("xof result {}", i)),
+            let xof_result = evaluate_blake2s_with_parameters(
                 &message,
                 &blake2s_parameters.parameters(),
             )?;
@@ -222,7 +222,7 @@ pub fn hash_to_bits<F: PrimeField, CS: ConstraintSystem<F>>(
                 .into_iter()
                 .map(|n| n.to_bits_le())
                 .flatten()
-                .collect::<Vec<Boolean>>();
+                .collect::<Vec<Boolean<F>>>();
             xof_bits.extend_from_slice(&xof_bits_i);
         }
         xof_bits
@@ -233,7 +233,7 @@ pub fn hash_to_bits<F: PrimeField, CS: ConstraintSystem<F>>(
         } else {
             let message = message
                 .iter()
-                .map(|m| m.get_value().get())
+                .map(|m| m.value())
                 .collect::<Result<Vec<_>, _>>()?;
             let message = bits_to_bytes(&message);
             let hash_result = DirectHasher.xof(&personalization, &message, 64).unwrap();
@@ -241,124 +241,131 @@ pub fn hash_to_bits<F: PrimeField, CS: ConstraintSystem<F>>(
             bits.reverse();
             bits
         };
-        constrain_bool(&mut cs, &bits)?
+
+        bits.iter()
+        .enumerate()
+        .map(|(_j, b)| Boolean::new_witness(message[..].cs().unwrap_or(ConstraintSystemRef::None), || Ok(b)))
+        .collect::<Result<Vec<_>, _>>()?
+//        constrain_bool(message[0].cs().unwrap_or(ConstraintSystemRef::None), &bits)?
     };
 
     Ok(xof_bits)
 }
 
-impl<P: Bls12Parameters> HashToGroupGadget<P> {
+impl<P: Bls12Parameters> HashToGroupGadget<P, Bls12_377_Fq> {
     // Receives the output of `HashToBitsGadget::hash_to_bits` in Little Endian
     // decodes the G1 point and then multiplies it by the curve's cofactor to
     // get the hash
-    fn hash_to_group<CS: ConstraintSystem<P::Fp>>(
-        mut cs: CS,
-        xof_bits: &[Boolean],
-    ) -> Result<G1Gadget<P>, SynthesisError> {
+    //#[tracing::instrument(target = "r1cs")]
+    fn hash_to_group(
+        xof_bits: &[Boolean<Bls12_377_Fq>],
+    ) -> Result<G1Var<Bls12_377_Parameters>, SynthesisError> {
         let span = span!(Level::TRACE, "HashToGroupGadget",);
         let _enter = span.enter();
 
-        let xof_bits = [&xof_bits[..X_BITS], &[xof_bits[SIGN_BIT_POSITION]]].concat();
-
+//        println!("{:?}", xof_bits.value());
+//        let xof_bits = [&xof_bits[..X_BITS], &[xof_bits[SIGN_BIT_POSITION]]].concat();
+        let x_bits = &xof_bits[..X_BITS];
+//        let greatest = &x_bits[X_BITS];
+        let sign_bit = &xof_bits[SIGN_BIT_POSITION];
         trace!("getting G1 point from bits");
         let expected_point_before_cofactor =
-            G1Gadget::<P>::alloc(cs.ns(|| "expected point before cofactor"), || {
+            <G1Var::<Bls12_377_Parameters>>::new_variable_omit_prime_order_check(
+                x_bits.cs().unwrap_or(ConstraintSystemRef::None),
+                || {
                 // if we're in setup mode, just return an error
-                if is_setup(&xof_bits) {
+                // TODO: setup should also be checked on sign bit
+                if is_setup(&x_bits) {
                     return Err(SynthesisError::AssignmentMissing);
                 }
 
-                let x_bits = &xof_bits[..X_BITS];
-                let greatest = xof_bits[X_BITS];
+//                let x_bits = &xof_bits[..X_BITS];
+//                let greatest = xof_bits[X_BITS];
 
                 // get the bits from the Boolean constraints
                 // we assume that these are already encoded as LE
                 let mut bits = x_bits
                     .iter()
-                    .map(|x| x.get_value().get())
+                    .map(|x| x.value())
                     .collect::<Result<Vec<bool>, _>>()?;
 
                 // `BigInt::from_bits` takes BigEndian representations so we need to
                 // reverse them since they are read in LE
-                bits.reverse();
-                let big = <P::Fp as PrimeField>::BigInt::from_bits(&bits);
-                let x = P::Fp::from_repr(big).get()?;
-                let greatest = greatest.get_value().get()?;
+ //               bits.reverse();
+                let big = <<Bls12_377_Parameters as Bls12Parameters>::Fp as PrimeField>::BigInt::from_bits(&bits);
+
+                let x = <Bls12_377_Parameters as Bls12Parameters>::Fp::from_repr(big).get()?;
+                let sign_bit_value = sign_bit.value()?;
+                println!("before getting point: {}", x);
 
                 // Converts the point read from the xof bits to a G1 element
                 // with point decompression
-                let p = GroupAffine::<P::G1Parameters>::get_point_from_x(x, greatest)
+                let p = GroupAffine::<<Bls12_377_Parameters as Bls12Parameters>::G1Parameters>::get_point_from_x(x, sign_bit_value)
                     .ok_or(SynthesisError::AssignmentMissing)?;
+                println!("after getting point: {}", p.x);
+//                println!("bitmap: {}", p.x.to_bits_le()?);
 
                 Ok(p.into_projective())
-            })?;
+            }, AllocationMode::Witness)?;
 
         trace!("compressing y");
+        println!("after converting to var: {}", expected_point_before_cofactor.x.value()?);
         // Point compression on the G1 Gadget
-        let compressed_point: Vec<Boolean> = {
+        let (compressed_point, compressed_sign_bit): (Vec<Boolean<Bls12_377_Fq>>, Boolean<Bls12_377_Fq>) = {
             // Convert x to LE
-            let mut bits: Vec<Boolean> =
-                expected_point_before_cofactor.x.to_bits(cs.ns(|| "bits"))?;
-            bits.reverse();
+            let mut bits: Vec<Boolean<Bls12_377_Fq>> =
+                expected_point_before_cofactor.x.to_bits_le()?;
+           bits.reverse();
 
             // Get a constraint about the y point's sign
-            let greatest_bit = YToBitGadget::<P>::y_to_bit_g1(
-                cs.ns(|| "y to bit"),
-                &expected_point_before_cofactor,
-            )?;
+            let greatest_bit = expected_point_before_cofactor.y_to_bit()?;
 
-            // return the x point plus the greatest bit constraint
-            bits.push(greatest_bit);
-
-            bits
+            (bits, greatest_bit)
         };
 
-        compressed_point
-            .iter()
-            .zip(xof_bits.iter())
-            .enumerate()
-            .for_each(|(i, (a, b))| {
-                cs.enforce(
-                    || format!("enforce bit {}", i),
-                    |lc| lc + (P::Fp::one(), CS::one()),
-                    |_| a.lc(CS::one(), P::Fp::one()),
-                    |_| b.lc(CS::one(), P::Fp::one()),
-                );
-            });
+        println!("{}    {}", compressed_point.len(), x_bits.len());
+        for (_i, (a,b)) in compressed_point.iter()
+            .zip(x_bits.iter())
+            .enumerate() 
+        {
+      //      println!("a: {:?}, b: {:?}", a.value()?, b.value()?);
+            a.enforce_equal(&b)?;
+        }
+     //   println!("a: {:?}", compressed_sign_bit.value()?);
+     //   println!("b: {:?}", sign_bit.value()?);
+        compressed_sign_bit.enforce_equal(&sign_bit)?;
 
         trace!("scaling by G1 cofactor");
 
         let scaled_point = Self::scale_by_cofactor_g1(
-            cs.ns(|| "scale by cofactor"),
             &expected_point_before_cofactor,
         )?;
 
         Ok(scaled_point)
     }
 
-    fn scale_by_cofactor_g1<CS: r1cs_core::ConstraintSystem<P::Fp>>(
-        mut cs: CS,
-        p: &G1Gadget<P>,
-    ) -> Result<G1Gadget<P>, SynthesisError>
+    fn scale_by_cofactor_g1(
+        p: &G1Var<Bls12_377_Parameters>,
+    ) -> Result<G1Var<Bls12_377_Parameters>, SynthesisError>
     where
-        G1Projective<P>: Borrow<GroupProjective<P::G1Parameters>>,
+        G1Projective<Bls12_377_Parameters>: Borrow<GroupProjective<<Bls12_377_Parameters as Bls12Parameters>::G1Parameters>>,
     {
         // get the cofactor's bits
-        let mut x_bits = BitIterator::new(P::G1Parameters::COFACTOR)
+        let mut x_bits = BitIteratorBE::new(P::G1Parameters::COFACTOR)
             .map(Boolean::constant)
-            .collect::<Vec<Boolean>>();
+            .collect::<Vec<Boolean<Bls12_377_Fq>>>();
 
         // Zexe's mul_bits requires that inputs _MUST_ be in LE form, so we have to reverse
         x_bits.reverse();
 
         // return p * cofactor - [g]_1
-        let generator = G1Gadget::<P>::alloc_constant(
-            cs.ns(|| "generator"),
-            G1Projective::<P>::prime_subgroup_generator(),
+        let generator = G1Var::<Bls12_377_Parameters>::new_constant(
+            p.cs().unwrap_or(ConstraintSystemRef::None),
+            G1Projective::<Bls12_377_Parameters>::prime_subgroup_generator(),
         )?;
         let scaled = p
-            .mul_bits(cs.ns(|| "scaled"), &generator, x_bits.iter())?
-            .sub(cs.ns(|| "scaled finalize"), &generator)?;
+            .scalar_mul_le(x_bits.iter())?
+            .sub(&generator);
         Ok(scaled)
     }
 }
@@ -367,8 +374,11 @@ impl<P: Bls12Parameters> HashToGroupGadget<P> {
 mod test {
     use super::*;
 
+    use bls_crypto::hashers::composite::COMPOSITE_HASHER;
+    use bls_crypto::hash_to_curve::HashToCurve;
     use algebra::bls12_377;
-    use r1cs_std::{groups::GroupGadget, test_constraint_system::TestConstraintSystem};
+    use r1cs_std::groups::CurveVar;
+    use r1cs_core::ConstraintSystem;
 
     use bls_crypto::hash_to_curve::try_and_increment::COMPOSITE_HASH_TO_G1;
     use r1cs_std::bits::uint8::UInt8;
@@ -376,9 +386,14 @@ mod test {
 
     #[test]
     fn test_hash_to_group() {
+        let mut layer = ConstraintLayer::default();
+        layer.mode = r1cs_core::TracingMode::OnlyConstraints;
+        let subscriber = tracing_subscriber::Registry::default().with(layer);
+        tracing::subscriber::set_global_default(subscriber).unwrap();
+
         let mut rng = thread_rng();
         // test for various input sizes
-        for length in &[10, 25, 50, 100, 200, 300] {
+        for length in &[10] /*, 25, 50, 100, 200, 300]*/ {
             // fill a buffer with random elements
             let mut input = vec![0; *length];
             rng.fill_bytes(&mut input);
@@ -393,20 +408,22 @@ mod test {
         let (expected_hash, attempt) = try_and_increment
             .hash_with_attempt(SIG_DOMAIN, input, &[])
             .unwrap();
+        let hasher = &*COMPOSITE_HASHER;
+//        let bits = hasher.hash(SIG_DOMAIN, input, 64);
+//        println!("gadget hash: {:?}", bits);
 
-        let mut cs = TestConstraintSystem::<bls12_377::Fq>::new();
+        let mut cs = ConstraintSystem::<bls12_377::Fq>::new_ref();
 
-        let counter = UInt8::alloc(&mut cs.ns(|| "alloc counter"), || Ok(attempt as u8)).unwrap();
+        let counter = UInt8::new_witness(cs.clone(), || Ok(attempt as u8)).unwrap();
         let input = input
             .iter()
             .enumerate()
             .map(|(i, num)| {
-                UInt8::alloc(&mut cs.ns(|| format!("input {}", i)), || Ok(num)).unwrap()
+                UInt8::new_witness(cs.clone(), || Ok(num)).unwrap()
             })
             .collect::<Vec<_>>();
 
-        let hash = HashToGroupGadget::<bls12_377::Parameters>::enforce_hash_to_group(
-            &mut cs.ns(|| "hash to group"),
+        let hash = HashToGroupGadget::<bls12_377::Parameters, bls12_377::Fq>::enforce_hash_to_group(
             counter,
             &input,
             false,
@@ -414,7 +431,14 @@ mod test {
         .unwrap()
         .0;
 
-        assert!(cs.is_satisfied());
-        assert_eq!(expected_hash, hash.get_value().unwrap());
+        if !cs.is_satisfied().unwrap() {
+            println!("=========================================================");
+            println!("Unsatisfied constraints:");
+            println!("{}", cs.which_is_unsatisfied().unwrap().unwrap());
+            println!("=========================================================");
+        }
+
+        assert!(cs.is_satisfied().unwrap());
+        assert_eq!(expected_hash, hash.value().unwrap());
     }
 }
diff --git a/crates/bls-gadgets/src/lib.rs b/crates/bls-gadgets/src/lib.rs
index abd97a6..e42b299 100644
--- a/crates/bls-gadgets/src/lib.rs
+++ b/crates/bls-gadgets/src/lib.rs
@@ -7,10 +7,10 @@ mod bls;
 pub use bls::BlsVerifyGadget;
 
 mod bitmap;
-pub(crate) use bitmap::enforce_maximum_occurrences_in_bitmap;
+pub(crate) use bitmap::Bitmap;
 
 mod y_to_bit;
-pub use y_to_bit::YToBitGadget;
+pub use y_to_bit::{YToBitGadget, FpUtils};
 
 mod hash_to_group;
 pub use hash_to_group::{hash_to_bits, HashToGroupGadget};
diff --git a/crates/bls-gadgets/src/utils.rs b/crates/bls-gadgets/src/utils.rs
index 37a9b6f..d962cea 100644
--- a/crates/bls-gadgets/src/utils.rs
+++ b/crates/bls-gadgets/src/utils.rs
@@ -1,11 +1,12 @@
-use algebra::Field;
-use r1cs_core::{ConstraintSystem, SynthesisError};
-use r1cs_std::{alloc::AllocGadget, boolean::Boolean};
-
+use algebra::{ 
+    PrimeField
+};
+use r1cs_std::boolean::Boolean;
+use r1cs_std::R1CSVar;
 /// Helper used to skip operations which should not be executed when running the
 /// trusted setup
-pub fn is_setup(message: &[Boolean]) -> bool {
-    message.iter().any(|m| m.get_value().is_none())
+pub fn is_setup<F: PrimeField>(message: &[Boolean<F>]) -> bool {
+    message.iter().any(|m| m.value().is_err())
 }
 
 /// Converts the provided bits to LE bytes
@@ -50,32 +51,33 @@ pub fn bytes_to_bits(bytes: &[u8], bits_to_take: usize) -> Vec<bool> {
         .collect()
 }
 
-pub(crate) fn constrain_bool<F: Field, CS: ConstraintSystem<F>>(
-    cs: &mut CS,
+/*pub(crate) fn constrain_bool<F: PrimeField>(
+    cs: ConstraintSystemRef<F>,
     input: &[bool],
-) -> Result<Vec<Boolean>, SynthesisError> {
+) -> Result<Vec<Boolean<F>>, SynthesisError> {
     input
         .iter()
         .enumerate()
-        .map(|(j, b)| Boolean::alloc(cs.ns(|| format!("{}", j)), || Ok(b)))
+        .map(|(_j, b)| Boolean::new_witness(cs, || Ok(b)))
         .collect::<Result<Vec<_>, _>>()
-}
+}*/
 
 #[cfg(any(test, feature = "test-helpers"))]
 pub mod test_helpers {
     use algebra::{Field, Group};
-    use r1cs_core::ConstraintSystem;
-    use r1cs_std::groups::GroupGadget;
+    use r1cs_core::ConstraintSystemRef;
+    use r1cs_std::groups::CurveVar;
+    use algebra::ProjectiveCurve;
 
-    /// Allocates an array of group elements to a group gadget
-    pub fn alloc_vec<F: Field, G: Group, GG: GroupGadget<G, F>, CS: ConstraintSystem<F>>(
-        cs: &mut CS,
+   // /// Allocates an array of group elements to a group gadget
+/*    pub fn alloc_vec<F: Field, G: ProjectiveCurve, GG: CurveVar<G, F>>(
+        cs: ConstraintSystemRef<F>,
         elements: &[G],
     ) -> Vec<GG> {
         elements
             .iter()
             .enumerate()
-            .map(|(i, element)| GG::alloc(&mut cs.ns(|| format!("{}", i)), || Ok(element)).unwrap())
+            .map(|(i, element)| GG::new_witness(cs.clone(), || Ok(element)).unwrap())
             .collect::<Vec<_>>()
-    }
+    }*/
 }
diff --git a/crates/bls-gadgets/src/y_to_bit.rs b/crates/bls-gadgets/src/y_to_bit.rs
index 55c2906..5a49b84 100644
--- a/crates/bls-gadgets/src/y_to_bit.rs
+++ b/crates/bls-gadgets/src/y_to_bit.rs
@@ -1,14 +1,15 @@
 #![allow(clippy::op_ref)] // clippy throws a false positive around field ops
-use algebra::{curves::bls12::Bls12Parameters, Field, One, PrimeField, Zero};
-use r1cs_core::{ConstraintSystem, SynthesisError};
+use algebra::{curves::bls12::Bls12Parameters, PrimeField, Zero};
+use algebra::bls12_377::Parameters as Bls12_377_Parameters;
+use r1cs_core::{SynthesisError, Variable, lc, ConstraintSystemRef, LinearCombination};
 use r1cs_std::{
-    alloc::AllocGadget,
+    R1CSVar,
+    alloc::AllocVar,
     boolean::Boolean,
-    fields::{fp::FpGadget, FieldGadget},
-    groups::curves::short_weierstrass::bls12::{G1Gadget, G2Gadget},
+    fields::{fp::FpVar},
+    groups::curves::short_weierstrass::bls12::{G1Var, G2Var},
     Assignment,
 };
-use std::{marker::PhantomData, ops::Neg};
 
 /// The goal of the gadget is to provide the bit according to the value of y,
 /// as done in point compression. The idea is that given $half = \frac{p-1}{2}$,
@@ -17,36 +18,46 @@ use std::{marker::PhantomData, ops::Neg};
 /// range). Then we check that the cast element is <= half, which enforces that
 /// originally they were > half. For points in G2, we also check the
 /// lexicographical ordering.
-pub struct YToBitGadget<P: Bls12Parameters> {
-    parameters_type: PhantomData<P>,
+pub trait YToBitGadget<P: Bls12Parameters> {
+    fn y_to_bit(&self) -> Result<Boolean<P::Fp>, SynthesisError>;
 }
 
-impl<P: Bls12Parameters> YToBitGadget<P> {
-    pub fn y_to_bit_g1<CS: ConstraintSystem<P::Fp>>(
-        mut cs: CS,
-        pk: &G1Gadget<P>,
-    ) -> Result<Boolean, SynthesisError> {
-        let y_bit = Self::normalize(&mut cs.ns(|| "g1 normalize"), &pk.y)?;
+pub trait FpUtils<F: PrimeField> {
+    fn is_eq_zero(
+        &self,
+    ) -> Result<Boolean<F>, SynthesisError>; 
+    fn normalize(
+        &self,
+    ) -> Result<Boolean<F>, SynthesisError>;
+}
+
+impl YToBitGadget<Bls12_377_Parameters> for G1Var<Bls12_377_Parameters> 
+{
+    fn y_to_bit(
+        &self,
+    ) -> Result<Boolean<<Bls12_377_Parameters as Bls12Parameters>::Fp>, SynthesisError> {
+        let y_bit = self.y.normalize()?;
         Ok(y_bit)
     }
+}
 
-    pub fn y_to_bit_g2<CS: ConstraintSystem<P::Fp>>(
-        mut cs: CS,
-        pk: &G2Gadget<P>,
-    ) -> Result<Boolean, SynthesisError> {
+impl YToBitGadget<Bls12_377_Parameters> for G2Var<Bls12_377_Parameters> {
+    fn y_to_bit(
+        &self,
+    ) -> Result<Boolean<<Bls12_377_Parameters as Bls12Parameters>::Fp>, SynthesisError> {
         // Apply the point compression logic for getting the y bit's value.
-        let y_bit = Boolean::alloc(cs.ns(|| "alloc y bit"), || {
-            let half = P::Fp::from_repr(P::Fp::modulus_minus_one_div_two()).get()?;
-            let c1 = pk.y.c1.get_value().get()?;
-            let c0 = pk.y.c0.get_value().get()?;
+            let y_bit = Boolean::new_witness(self.cs().unwrap_or(ConstraintSystemRef::None), || {
+            let half = <Bls12_377_Parameters as Bls12Parameters>::Fp::from_repr(<Bls12_377_Parameters as Bls12Parameters>::Fp::modulus_minus_one_div_two()).get()?;
+            let c1 = self.y.c1.value()?;
+            let c0 = self.y.c0.value()?;
 
-            let bit = c1 > half || (c1 == P::Fp::zero() && c0 > half);
+            let bit = c1 > half || (c1 == <Bls12_377_Parameters as Bls12Parameters>::Fp::zero() && c0 > half);
             Ok(bit)
         })?;
 
         // Get the y_c1 and y_c0 bits
-        let y_c0_bit = Self::normalize(&mut cs.ns(|| "normalize c0"), &pk.y.c0)?;
-        let y_c1_bit = Self::normalize(&mut cs.ns(|| "normalize c1"), &pk.y.c1)?;
+        let y_c0_bit = self.y.c0.normalize()?;
+        let y_c1_bit = self.y.c1.normalize()?;
 
         // (1-a)*(b*c) == o - a
         // a is c1
@@ -58,27 +69,25 @@ impl<P: Bls12Parameters> YToBitGadget<P> {
         // either c1 is 1, and then o is 1
         // else c1 is 0 and c0 is 1 (then y_eq is 1), and then o is 1
         // else c1 is 0 and c0 is 0 (then y_eq is 1), and then o is 0
-        let y_eq_bit = Self::is_eq_zero(&mut cs.ns(|| "c1 == 0"), &pk.y.c1)?;
-        let bc = Boolean::and(cs.ns(|| "and bc"), &y_eq_bit, &y_c0_bit)?;
-
-        cs.enforce(
-            || "enforce y bit derived correctly",
-            |lc| lc + (P::Fp::one(), CS::one()) + y_c1_bit.lc(CS::one(), P::Fp::one().neg()),
-            |_| bc.lc(CS::one(), P::Fp::one()),
-            |lc| {
-                lc + y_bit.lc(CS::one(), P::Fp::one()) + y_c1_bit.lc(CS::one(), P::Fp::one().neg())
-            },
-        );
+        let y_eq_bit = self.y.c1.is_eq_zero()?;
+        let bc = Boolean::and(&y_eq_bit, &y_c0_bit)?;
+
+        self.cs().unwrap_or(ConstraintSystemRef::None).enforce_constraint(
+            LinearCombination::from(Variable::One) - y_c1_bit.lc(),
+            bc.lc(),
+            y_bit.lc() - y_c1_bit.lc(),
+        )?;
 
         Ok(y_bit)
     }
+}
 
-    pub fn is_eq_zero<CS: ConstraintSystem<P::Fp>>(
-        cs: &mut CS,
-        el: &FpGadget<P::Fp>,
-    ) -> Result<Boolean, SynthesisError> {
-        let bit = Boolean::alloc(cs.ns(|| "alloc bit"), || {
-            Ok(el.get_value().get()? == P::Fp::zero())
+impl<F: PrimeField> FpUtils<F> for FpVar<F> {
+    fn is_eq_zero(
+        &self,
+    ) -> Result<Boolean<F>, SynthesisError> {
+        let bit = Boolean::new_witness(self.cs().unwrap_or(ConstraintSystemRef::None),
+            || { Ok(self.value()? == F::zero())
         })?;
 
         // This enforces bit = 1 <=> el == 0.
@@ -87,57 +96,73 @@ impl<P: Bls12Parameters> YToBitGadget<P> {
         // `el*result == 0` forces result to be 0. inv is set to be 0 in case el is 0 because
         // the value of el_inv is not significant in that case (el is 0 anyway) and we need the
         // witness calculation to pass.
-        let inv = FpGadget::alloc(cs.ns(|| "alloc inv"), || {
-            Ok(el.get_value().get()?.inverse().unwrap_or_else(P::Fp::zero))
+        let inv = FpVar::new_witness(self.cs().unwrap_or(ConstraintSystemRef::None), 
+            || { Ok(self.value()?.inverse().unwrap_or(F::zero()))
         })?;
 
         // (el * inv == 1 - bit)
-        cs.enforce(
-            || "enforce y_eq_bit",
-            |lc| el.get_variable() + lc,
-            |lc| inv.get_variable() + lc,
-            |lc| lc + (P::Fp::one(), CS::one()) + bit.lc(CS::one(), P::Fp::one().neg()),
-        );
+        self.cs().unwrap_or(ConstraintSystemRef::None).enforce_constraint(
+            // TODO: What to do with constant FpVars here? Should probably just not enforce
+            // constraints if both are constants
+            match self { 
+                Self::Constant(_) => lc!(),
+                Self::Var(v) => LinearCombination::from(v.variable) + lc!(),
+            },
+            match inv { 
+                Self::Constant(_) => lc!(),
+                Self::Var(v) => LinearCombination::from(v.variable) + lc!(),
+            },
+            LinearCombination::from(Variable::One) - bit.lc(),
+        )?;
 
         // (lhs * bit == 0)
-        cs.enforce(
-            || "enforce y_eq_bit 2",
-            |lc| el.get_variable() + lc,
-            |_| bit.lc(CS::one(), P::Fp::one()),
-            |lc| lc,
-        );
+        self.cs().unwrap_or(ConstraintSystemRef::None).enforce_constraint(
+            match self {
+                Self::Constant(_) => lc!(),
+                Self::Var(v) => LinearCombination::from(v.variable) + lc!(),
+            },
+            bit.lc(),
+            lc!(),
+        )?;
 
         Ok(bit)
     }
 
     // Returns 1 if el > half, else 0.
-    fn normalize<CS: ConstraintSystem<P::Fp>>(
-        cs: &mut CS,
-        el: &FpGadget<P::Fp>,
-    ) -> Result<Boolean, SynthesisError> {
-        let half = P::Fp::from_repr(P::Fp::modulus_minus_one_div_two()).get()?;
+    fn normalize(
+        &self,
+    ) -> Result<Boolean<F>, SynthesisError> {
+        let half = F::from_repr(F::modulus_minus_one_div_two()).get()?;
 
-        let bit = Boolean::alloc(cs.ns(|| "alloc y bit"), || Ok(el.get_value().get()? > half))?;
+        let bit = Boolean::new_witness(self.cs().unwrap_or(ConstraintSystemRef::None), 
+            || Ok(self.value()? > half))?;
 
-        let adjusted = FpGadget::alloc(cs.ns(|| "alloc y"), || {
-            let el = el.get_value().get()?;
+        let adjusted = FpVar::new_witness(
+            self.cs().unwrap_or(ConstraintSystemRef::None),
+            || {
+            let el = self.value()?;
 
             let adjusted = if el > half { el - &half } else { el };
 
             Ok(adjusted)
         })?;
 
-        let bit_lc = bit.lc(CS::one(), half.neg());
-        cs.enforce(
-            || "check bit",
-            |lc| lc + (P::Fp::one(), CS::one()),
-            |lc| el.get_variable() + bit_lc + lc,
-            |lc| adjusted.get_variable() + lc,
-        );
+        let adjusted_var = match adjusted {
+            Self::Var(ref v) => v,
+            _ => panic!("adjusted wrong type"),
+        };
+        // TODO: Figure out what to do with constant FpVar
+        self.cs().unwrap_or(ConstraintSystemRef::None).enforce_constraint(
+            lc!() +  LinearCombination::from(Variable::One),
+            match self {
+                Self::Constant(_) => lc!(),
+                Self::Var(ref v) => LinearCombination::from(v.variable),
+            } + (bit.lc() * half.neg()),
+            LinearCombination::from(adjusted_var.variable)
+        )?;
 
         // Enforce `adjusted <= half`
-        FpGadget::enforce_smaller_or_equal_than_mod_minus_one_div_two(
-            cs.ns(|| "enforce smaller than or equal to modulus minus one div two"),
+        FpVar::enforce_smaller_or_equal_than_mod_minus_one_div_two(
             &adjusted,
         )?;
 
@@ -149,6 +174,8 @@ impl<P: Bls12Parameters> YToBitGadget<P> {
 mod test {
     use super::*;
 
+    use r1cs_std::groups::CurveVar;
+    use r1cs_std::alloc::AllocationMode;
     use algebra::{
         bls12_377::{G1Projective, G2Affine, G2Projective, Parameters},
         bw6_761::Fr as BW6_761Fr,
@@ -156,11 +183,12 @@ mod test {
         fields::Fp2,
         AffineCurve, BigInteger, PrimeField, UniformRand, Zero,
     };
+    use r1cs_core::ConstraintSystem;
     use r1cs_std::{
-        alloc::AllocGadget,
-        fields::FieldGadget,
-        groups::curves::short_weierstrass::bls12::{G1Gadget, G2Gadget},
-        test_constraint_system::TestConstraintSystem,
+        alloc::AllocVar,
+        fields::FieldVar,
+        groups::curves::short_weierstrass::bls12::{G1Var, G2Var},
+//        test_constraint_system::TestConstraintSystem,
         Assignment,
     };
 
@@ -174,24 +202,23 @@ mod test {
         for _ in 0..10 {
             let element = G1Projective::rand(rng);
 
-            let mut cs = TestConstraintSystem::<BW6_761Fr>::new();
+            let mut cs = ConstraintSystem::<BW6_761Fr>::new_ref();
 
             let allocated =
-                G1Gadget::<Parameters>::alloc(&mut cs.ns(|| "alloc"), || Ok(element)).unwrap();
+                G1Var::<Parameters>::new_variable_omit_prime_order_check(cs.clone(), || Ok(element), AllocationMode::Witness).unwrap();
 
-            let y_bit =
-                YToBitGadget::<Parameters>::y_to_bit_g1(cs.ns(|| "y to bit"), &allocated).unwrap();
+            let y_bit = allocated.y_to_bit().unwrap();
 
             assert_eq!(
-                allocated.y.get_value().get().unwrap() > half,
-                y_bit.get_value().get().unwrap()
+                allocated.y.value().unwrap() > half,
+                y_bit.value().unwrap()
             );
 
-            assert_eq!(cs.num_constraints(), 1621);
-            if !cs.is_satisfied() {
-                println!("{}", cs.which_is_unsatisfied().unwrap());
+//            assert_eq!(cs.num_constraints(), 1621);
+            if !cs.is_satisfied().unwrap() {
+                println!("{:?}", cs.which_is_unsatisfied().unwrap());
             }
-            assert!(cs.is_satisfied());
+            assert!(cs.is_satisfied().unwrap());
         }
     }
 
@@ -205,28 +232,27 @@ mod test {
         for _ in 0..10 {
             let element = G2Projective::rand(rng);
 
-            let mut cs = TestConstraintSystem::<BW6_761Fr>::new();
+            let mut cs = ConstraintSystem::<BW6_761Fr>::new_ref();
 
             let allocated =
-                G2Gadget::<Parameters>::alloc(&mut cs.ns(|| "alloc"), || Ok(element)).unwrap();
+                G2Var::<Parameters>::new_witness(cs.clone(), || Ok(element)).unwrap();
 
-            let y_bit =
-                YToBitGadget::<Parameters>::y_to_bit_g2(cs.ns(|| "y to bit"), &allocated).unwrap();
+            let y_bit = allocated.y_to_bit().unwrap();
 
-            let c1 = allocated.y.c1.get_value().unwrap();
-            let c0 = allocated.y.c0.get_value().unwrap();
+            let c1 = allocated.y.c1.value().unwrap();
+            let c0 = allocated.y.c0.value().unwrap();
 
             if c1 > half || (c1 == zero && c0 > half) {
-                assert_eq!(true, y_bit.get_value().unwrap());
+                assert_eq!(true, y_bit.value().unwrap());
             } else {
-                assert_eq!(false, y_bit.get_value().unwrap());
+                assert_eq!(false, y_bit.value().unwrap());
             }
 
-            assert_eq!(cs.num_constraints(), 3248);
-            if !cs.is_satisfied() {
-                println!("{}", cs.which_is_unsatisfied().unwrap());
+  //          assert_eq!(cs.num_constraints(), 3248);
+            if !cs.is_satisfied().unwrap() {
+                println!("{:?}", cs.which_is_unsatisfied().unwrap());
             }
-            assert!(cs.is_satisfied());
+            assert!(cs.is_satisfied().unwrap());
         }
     }
 
@@ -242,24 +268,23 @@ mod test {
                 Fp2::<<Parameters as Bls12Parameters>::Fp2Params>::new(element.y.c0, edge.into());
             let element = G2Affine::new(element.x, new_y, false).into_projective();
 
-            let mut cs = TestConstraintSystem::<BW6_761Fr>::new();
+            let mut cs = ConstraintSystem::<BW6_761Fr>::new_ref();
 
             let allocated =
-                G2Gadget::<Parameters>::alloc(&mut cs.ns(|| "alloc"), || Ok(element)).unwrap();
+                G2Var::<Parameters>::new_witness(cs.clone(), || Ok(element)).unwrap();
 
-            let y_bit =
-                YToBitGadget::<Parameters>::y_to_bit_g2(cs.ns(|| "y to bit"), &allocated).unwrap();
+            let y_bit = allocated.y_to_bit().unwrap();
 
-            let c1 = allocated.y.c1.get_value().unwrap();
-            let c0 = allocated.y.c0.get_value().unwrap();
+            let c1 = allocated.y.c1.value().unwrap();
+            let c0 = allocated.y.c0.value().unwrap();
 
             if c1 > half || (c1 == zero && c0 > half) {
-                assert_eq!(true, y_bit.get_value().unwrap());
+                assert_eq!(true, y_bit.value().unwrap());
             } else {
-                assert_eq!(false, y_bit.get_value().unwrap());
+                assert_eq!(false, y_bit.value().unwrap());
             }
 
-            assert_eq!(cs.num_constraints(), 3248);
+    //        assert_eq!(cs.num_constraints(), 3248);
             // we're not checking this, because we couldn't find a matching point on BLS12-377,
             // and so we can't generate proper points on the curve
             /*
diff --git a/crates/bls-snark-sys/Cargo.toml b/crates/bls-snark-sys/Cargo.toml
index 5439f7a..c32158b 100644
--- a/crates/bls-snark-sys/Cargo.toml
+++ b/crates/bls-snark-sys/Cargo.toml
@@ -8,7 +8,7 @@ edition = "2018"
 bls-crypto = { path = "../bls-crypto", features = ["compat"] }
 epoch-snark = { path = "../epoch-snark", features = ["compat"] }
 
-algebra = { git = "https://github.com/scipr-lab/zexe", default-features = false, features = ["bls12_377", "parallel"] }
+algebra = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", default-features = false, features = ["bls12_377", "parallel"] }
 once_cell = "1.4.0"
 rand = "0.7.3"
 log = "0.4.8"
@@ -17,7 +17,7 @@ log = "0.4.8"
 crate-type = ["lib", "staticlib"]
 
 [dev-dependencies]
-groth16 = { git = "https://github.com/scipr-lab/zexe", features = ["parallel"] }
-r1cs-core = { git = "https://github.com/scipr-lab/zexe" }
+groth16 = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", features = ["parallel"] }
+r1cs-core = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs" }
 hex = "0.4.2"
 
diff --git a/crates/bls-snark-sys/src/serialization.rs b/crates/bls-snark-sys/src/serialization.rs
index 5a80a50..bbd22ee 100644
--- a/crates/bls-snark-sys/src/serialization.rs
+++ b/crates/bls-snark-sys/src/serialization.rs
@@ -93,7 +93,7 @@ fn deserialize<T: CanonicalDeserialize>(
 ) -> bool {
     convert_result_to_bool::<_, BLSError, _>(|| {
         let bytes = unsafe { slice::from_raw_parts(in_bytes, in_bytes_len as usize) };
-        let key = T::deserialize(&mut &bytes[..])?;
+        let key: T = CanonicalDeserialize::deserialize(&mut &bytes[..])?;
         unsafe {
             *out = Box::into_raw(Box::new(key));
         }
diff --git a/crates/epoch-snark/Cargo.toml b/crates/epoch-snark/Cargo.toml
index 49927c3..aa658a3 100644
--- a/crates/epoch-snark/Cargo.toml
+++ b/crates/epoch-snark/Cargo.toml
@@ -8,11 +8,12 @@ edition = "2018"
 bls-crypto = { path = "../bls-crypto", default-features = false }
 bls-gadgets = { path = "../bls-gadgets", default-features = false }
 
-algebra = { git = "https://github.com/scipr-lab/zexe", features = ["bls12_377", "bw6_761", "ed_on_bw6_761", "ed_on_bls12_377", "parallel"] }
-r1cs-core = { git = "https://github.com/scipr-lab/zexe" }
-r1cs-std = { git = "https://github.com/scipr-lab/zexe", features = ["bls12_377", "ed_on_bw6_761", "ed_on_bls12_377", "parallel"] }
-crypto-primitives = { git = "https://github.com/scipr-lab/zexe", features = ["r1cs", "groth16", "parallel"] }
-groth16 = { git = "https://github.com/scipr-lab/zexe", features = ["parallel"] }
+algebra = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", features = ["bls12_377", "bw6_761", "ed_on_bw6_761", "ed_on_bls12_377", "parallel"] }
+algebra-core = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs" } 
+r1cs-core = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs" }
+r1cs-std = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", features = ["bls12_377", "ed_on_bw6_761", "ed_on_bls12_377", "parallel"] }
+crypto-primitives = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", features = ["r1cs", "groth16", "parallel"] }
+groth16 = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs", features = ["parallel"] }
 
 rand = "0.7" 
 byteorder = "1.3.2"
@@ -23,7 +24,7 @@ tracing = "0.1.13"
 
 [dev-dependencies]
 rand_xorshift = { version = "0.2" }
-bench-utils = { git = "https://github.com/scipr-lab/zexe" }
+bench-utils = { git = "https://github.com/scipr-lab/zexe", branch = "better-r1cs-docs" }
 bls-gadgets = { path = "../bls-gadgets", default-features = false, features = ["test-helpers"] }
 bls-crypto = { path = "../bls-crypto", default-features = false, features = ["test-helpers"] }
 hex = "0.4.2"
diff --git a/crates/epoch-snark/src/gadgets/epoch_bits.rs b/crates/epoch-snark/src/gadgets/epoch_bits.rs
index f8b1518..f1c0154 100644
--- a/crates/epoch-snark/src/gadgets/epoch_bits.rs
+++ b/crates/epoch-snark/src/gadgets/epoch_bits.rs
@@ -1,27 +1,29 @@
 use algebra::{
-    bls12_377::{Bls12_377, Fr as BlsFr, FrParameters as BlsFrParameters},
+    curves::bls12::Bls12Parameters,
+    bls12_377::{Bls12_377, Fr as BlsFr, FrParameters as BlsFrParameters, Parameters as Bls12_377_Parameters},
     bw6_761::{Fr, FrParameters},
     FpParameters,
 };
-use r1cs_std::bls12_377::PairingGadget;
+use r1cs_std::bls12_377::PairingVar;
 use r1cs_std::prelude::*;
 
-use r1cs_core::{ConstraintSystem, SynthesisError};
+use r1cs_core::{ConstraintSystemRef, SynthesisError};
 
 // Groth16 Specific imports
 use crypto_primitives::{
     nizk::{
         constraints::NIZKVerifierGadget,
         groth16::{
-            constraints::{Groth16VerifierGadget, ProofGadget, VerifyingKeyGadget},
+            constraints::{Groth16VerifierGadget, ProofVar, VerifyingKeyVar},
             Groth16,
         },
     },
-    prf::blake2s::{constraints::blake2s_gadget_with_parameters, Blake2sWithParameterBlock},
+    prf::blake2s::{constraints::evaluate_blake2s_with_parameters, Blake2sWithParameterBlock},
 };
 
-use r1cs_std::fields::fp::FpGadget;
-type FrGadget = FpGadget<Fr>;
+use r1cs_std::fields::fp::FpVar;
+type FrVar = FpVar<Fr>;
+type Bool = Boolean<<Bls12_377_Parameters as Bls12Parameters>::Fp>;
 
 use crate::gadgets::{HashToBits, HashToBitsHelper, MultipackGadget};
 use bls_crypto::OUT_DOMAIN;
@@ -30,42 +32,41 @@ use bls_crypto::OUT_DOMAIN;
 /// which are used for verifying the CRH -> XOF hash calculation
 pub struct EpochBits {
     /// The first epoch's bits
-    pub first_epoch_bits: Vec<Boolean>,
+    pub first_epoch_bits: Vec<Bool>,
     /// The last epoch's bits
-    pub last_epoch_bits: Vec<Boolean>,
+    pub last_epoch_bits: Vec<Bool>,
     /// The CRH bits for all intermediate state transitions
-    pub crh_bits: Vec<Boolean>,
+    pub crh_bits: Vec<Bool>,
     /// The XOF bits for all intermediate state transitions
-    pub xof_bits: Vec<Boolean>,
+    pub xof_bits: Vec<Bool>,
 }
 
 impl EpochBits {
     /// Verify that the intermediate proofs are computed correctly and that the edges are correctly calculated
-    pub fn verify<CS: ConstraintSystem<Fr>>(
+    pub fn verify(
         &self,
-        cs: &mut CS,
         helper: Option<HashToBitsHelper<Bls12_377>>,
+        cs: ConstraintSystemRef<<Bls12_377_Parameters as Bls12Parameters>::Fp>
     ) -> Result<(), SynthesisError> {
         // Only verify the proof if it was provided
         if let Some(helper) = helper {
-            self.verify_proof(&mut cs.ns(|| "verify proof"), &helper)?;
+            self.verify_proof(&helper, cs)?;
         }
-        self.verify_edges(&mut cs.ns(|| "verify edges"))?;
+        self.verify_edges()?;
         Ok(())
     }
 
-    fn verify_edges<CS: ConstraintSystem<Fr>>(
+    fn verify_edges(
         &self,
-        cs: &mut CS,
-    ) -> Result<Vec<FrGadget>, SynthesisError> {
+    ) -> Result<Vec<FrVar>, SynthesisError> {
         // Verify the edges
         let mut xof_bits = vec![];
         let first_and_last_bits = [self.first_epoch_bits.clone(), self.last_epoch_bits.clone()];
-        for (i, bits) in first_and_last_bits.iter().enumerate() {
+        for (_i, bits) in first_and_last_bits.iter().enumerate() {
             let mut message = bits.to_owned();
             message.reverse();
             let message_rounded_len = 8 * ((message.len() + 7) / 8);
-            message.resize(message_rounded_len, Boolean::constant(false));
+            message.resize(message_rounded_len, Bool::constant(false));
 
             let mut personalization = [0; 8];
             personalization.copy_from_slice(OUT_DOMAIN);
@@ -83,8 +84,7 @@ impl EpochBits {
                 salt: [0; 8],
                 personalization,
             };
-            let xof_result = blake2s_gadget_with_parameters(
-                cs.ns(|| format!("first and last xof result {}", i)),
+            let xof_result = evaluate_blake2s_with_parameters(
                 &message,
                 &blake2s_parameters.parameters(),
             )?;
@@ -92,14 +92,13 @@ impl EpochBits {
                 .into_iter()
                 .map(|n| n.to_bits_le())
                 .flatten()
-                .collect::<Vec<Boolean>>();
+                .collect::<Vec<Bool>>();
             xof_bits.extend_from_slice(&xof_bits_i);
         }
 
         // Make the edges public inputs
         // packed over BW6_761 Fr.
         let packed = MultipackGadget::pack(
-            cs.ns(|| "pack output hash"),
             &xof_bits,
             FrParameters::CAPACITY as usize,
             true,
@@ -109,19 +108,20 @@ impl EpochBits {
     }
 
     /// Ensure that the intermediate BH and Blake2 hashes match
-    fn verify_proof<CS: ConstraintSystem<Fr>>(
+    fn verify_proof(
         &self,
-        cs: &mut CS,
         helper: &HashToBitsHelper<Bls12_377>,
+        cs: ConstraintSystemRef<<Bls12_377_Parameters as Bls12Parameters>::Fp>
     ) -> Result<(), SynthesisError> {
         // Verify the proof
-        let proof = ProofGadget::<_, _, PairingGadget>::alloc(cs.ns(|| "alloc proof"), || {
+        let proof = ProofVar::<_, PairingVar>::new_witness(cs, 
+        || {
             Ok(helper.proof.clone())
         })?;
 
         // Allocate the VK
-        let verifying_key = VerifyingKeyGadget::<_, _, PairingGadget>::alloc_constant(
-            cs.ns(|| "allocate verifying key"),
+        let verifying_key = VerifyingKeyVar::<_, PairingVar>::new_constant(
+            proof.a.cs().unwrap_or(ConstraintSystemRef::None),
             helper.verifying_key.clone(),
         )?;
 
@@ -130,13 +130,12 @@ impl EpochBits {
         let packed_crh_bits = le_chunks(&self.crh_bits, BlsFrParameters::CAPACITY);
         let packed_xof_bits = le_chunks(&self.xof_bits, BlsFrParameters::CAPACITY);
 
-        let public_inputs: Vec<Vec<Boolean>> = [packed_crh_bits, packed_xof_bits].concat();
+        let public_inputs: Vec<Vec<Bool>> = [packed_crh_bits, packed_xof_bits].concat();
 
-        <Groth16VerifierGadget<_, _, PairingGadget> as NIZKVerifierGadget<
+        <Groth16VerifierGadget<_, PairingVar> as NIZKVerifierGadget<
             Groth16<Bls12_377, HashToBits, BlsFr>,
             Fr,
-        >>::check_verify(
-            cs.ns(|| "verify hash proof"),
+        >>::verify(
             &verifying_key,
             public_inputs.iter(),
             &proof,
@@ -146,7 +145,7 @@ impl EpochBits {
     }
 }
 
-fn le_chunks(iter: &[Boolean], chunk_size: u32) -> Vec<Vec<Boolean>> {
+fn le_chunks(iter: &[Bool], chunk_size: u32) -> Vec<Vec<Bool>> {
     iter.chunks(chunk_size as usize)
         .map(|b| {
             let mut b = b.to_vec();
@@ -156,7 +155,7 @@ fn le_chunks(iter: &[Boolean], chunk_size: u32) -> Vec<Vec<Boolean>> {
         .collect::<Vec<_>>()
 }
 
-#[cfg(test)]
+/*#[cfg(test)]
 mod tests {
     use super::*;
     use bls_gadgets::utils::bytes_to_bits;
@@ -166,8 +165,8 @@ mod tests {
     use crate::gadgets::pack;
     use r1cs_std::test_constraint_system::TestConstraintSystem;
 
-    fn to_bool(iter: &[bool]) -> Vec<Boolean> {
-        iter.iter().map(|b| Boolean::constant(*b)).collect()
+    fn to_bool(iter: &[bool]) -> Vec<Bool> {
+        iter.iter().map(|b| Bool::constant(*b)).collect()
     }
 
     #[test]
@@ -207,4 +206,4 @@ mod tests {
         let public_inputs = pack::<Fr, FrParameters>(&both_blake_bits).unwrap();
         assert_eq!(inner, public_inputs);
     }
-}
+}*/
diff --git a/crates/epoch-snark/src/gadgets/epoch_data.rs b/crates/epoch-snark/src/gadgets/epoch_data.rs
index 217fc8c..a43fe23 100644
--- a/crates/epoch-snark/src/gadgets/epoch_data.rs
+++ b/crates/epoch-snark/src/gadgets/epoch_data.rs
@@ -1,23 +1,28 @@
 use algebra::{
-    bls12_377::{Bls12_377, Parameters},
+    curves::bls12::Bls12Parameters,
+    bls12_377::{Bls12_377, Parameters as Bls12_377_Parameters, Fq as Bls12_377_Fq},
     bw6_761::Fr,
     One, PairingEngine,
 };
-use bls_gadgets::{utils::is_setup, HashToGroupGadget, YToBitGadget};
-use r1cs_core::{ConstraintSystem, SynthesisError};
+use bls_gadgets::{utils::is_setup, 
+    FpUtils, 
+    HashToGroupGadget, 
+};
+use r1cs_core::{ConstraintSystemRef, SynthesisError};
 use r1cs_std::{
-    bls12_377::{G1Gadget, G2Gadget},
-    fields::fp::FpGadget,
+    bls12_377::{G1Var, G2Var},
+    fields::fp::FpVar,
     prelude::*,
     Assignment,
 };
-
 use bls_crypto::{hash_to_curve::try_and_increment::COMPOSITE_HASH_TO_G1, SIG_DOMAIN};
 
-use super::{fr_to_bits, g2_to_bits, to_fr};
+use super::{fr_to_bits, g2_to_bits};
 use tracing::{span, trace, Level};
 
-type FrGadget = FpGadget<Fr>;
+type FrVar = FpVar<Fr>;
+type Bool = Boolean<<Bls12_377_Parameters as Bls12Parameters>::Fp>;
+type U8 = UInt8<<Bls12_377_Parameters as Bls12Parameters>::Fp>;
 
 /// An epoch block using optional types so that it can be used to instantiate the
 /// trusted setup. Its non-gadget compatible equivalent is [`EpochBlock`]
@@ -39,19 +44,19 @@ pub struct EpochData<E: PairingEngine> {
 /// [`EpochData.constrain`]: struct.EpochData.html#method.constrain
 pub struct ConstrainedEpochData {
     /// The epoch's index
-    pub index: FrGadget,
+    pub index: FrVar,
     /// The new threshold needed for signatures
-    pub maximum_non_signers: FrGadget,
+    pub maximum_non_signers: FrVar,
     /// The epoch's G1 Hash
-    pub message_hash: G1Gadget,
+    pub message_hash: G1Var,
     /// The new validators for this epoch
-    pub pubkeys: Vec<G2Gadget>,
+    pub pubkeys: Vec<G2Var>,
     /// Serialized epoch data containing the index, max non signers, aggregated pubkey and the pubkeys array
-    pub bits: Vec<Boolean>,
+    pub bits: Vec<Bool>,
     /// Aux data for proving the CRH->XOF hash outside of BW6_761
-    pub crh_bits: Vec<Boolean>,
+    pub crh_bits: Vec<Bool>,
     /// Aux data for proving the CRH->XOF hash outside of BW6_761
-    pub xof_bits: Vec<Boolean>,
+    pub xof_bits: Vec<Bool>,
 }
 
 impl<E: PairingEngine> EpochData<E> {
@@ -69,20 +74,18 @@ impl EpochData<Bls12_377> {
     /// Ensures that the epoch's index is equal to `previous_index + 1`. Enforces that
     /// the epoch's G1 hash is correctly calculated, and also provides auxiliary data for
     /// verifying the CRH->XOF hash outside of BW6_761.
-    pub fn constrain<CS: ConstraintSystem<Fr>>(
+    pub fn constrain(
         &self,
-        cs: &mut CS,
-        previous_index: &FrGadget,
+        previous_index: &FrVar,
         generate_constraints_for_hash: bool,
     ) -> Result<ConstrainedEpochData, SynthesisError> {
         let span = span!(Level::TRACE, "EpochData");
         let _enter = span.enter();
-        let (bits, index, maximum_non_signers, pubkeys) = self.to_bits(cs)?;
-        Self::enforce_next_epoch(&mut cs.ns(|| "enforce next epoch"), previous_index, &index)?;
+        let (bits, index, maximum_non_signers, pubkeys) = self.to_bits(previous_index.cs().unwrap_or(ConstraintSystemRef::None))?;
+        Self::enforce_next_epoch(previous_index, &index)?;
 
         // Hash to G1
         let (message_hash, crh_bits, xof_bits) = Self::hash_bits_to_g1(
-            &mut cs.ns(|| "hash epoch to g1 bits"),
             &bits,
             generate_constraints_for_hash,
         )?;
@@ -99,31 +102,28 @@ impl EpochData<Bls12_377> {
     }
 
     /// Encodes the epoch to bits (index and non-signers encoded as LE)
-    pub fn to_bits<CS: ConstraintSystem<Fr>>(
+    pub fn to_bits(
         &self,
-        cs: &mut CS,
-    ) -> Result<(Vec<Boolean>, FrGadget, FrGadget, Vec<G2Gadget>), SynthesisError> {
-        let index = to_fr(&mut cs.ns(|| "index"), self.index)?;
-        let index_bits = fr_to_bits(&mut cs.ns(|| "index bits"), &index, 16)?;
-
-        let maximum_non_signers = to_fr(
-            &mut cs.ns(|| "max non signers"),
-            Some(self.maximum_non_signers),
-        )?;
+        cs: ConstraintSystemRef<Bls12_377_Fq>,
+    ) -> Result<(Vec<Bool>, FrVar, FrVar, Vec<G2Var>), SynthesisError> {
+        let index = FpVar::new_witness(cs, || Ok(Fr::from(self.index.get()?)))?;
+        let index_bits = fr_to_bits(&index, 16)?;
+
+        let maximum_non_signers = FpVar::new_witness(index.cs().unwrap_or(ConstraintSystemRef::None), || Ok(Fr::from(self.maximum_non_signers)))?;
+
         let maximum_non_signers_bits = fr_to_bits(
-            &mut cs.ns(|| "max non signers bits"),
             &maximum_non_signers,
             32,
         )?;
 
-        let mut epoch_bits: Vec<Boolean> = [index_bits, maximum_non_signers_bits].concat();
+        let mut epoch_bits: Vec<Bool> = [index_bits, maximum_non_signers_bits].concat();
 
         let mut pubkey_vars = Vec::with_capacity(self.public_keys.len());
-        for (j, maybe_pk) in self.public_keys.iter().enumerate() {
-            let pk_var = G2Gadget::alloc(cs.ns(|| format!("pub key {}", j)), || maybe_pk.get())?;
+        for (_j, maybe_pk) in self.public_keys.iter().enumerate() {
+            let pk_var = G2Var::new_witness(index.cs().unwrap_or(ConstraintSystemRef::None), || maybe_pk.get())?;
 
             // extend our epoch bits by the pubkeys
-            let pk_bits = g2_to_bits(&mut cs.ns(|| format!("pubkey to bits {}", j)), &pk_var)?;
+            let pk_bits = g2_to_bits(&pk_var)?;
             epoch_bits.extend_from_slice(&pk_bits);
 
             // save the allocated pubkeys
@@ -134,19 +134,19 @@ impl EpochData<Bls12_377> {
     }
 
     /// Enforces that `index = previous_index + 1`
-    fn enforce_next_epoch<CS: ConstraintSystem<Fr>>(
-        cs: &mut CS,
-        previous_index: &FrGadget,
-        index: &FrGadget,
+    fn enforce_next_epoch(
+        previous_index: &FrVar,
+        index: &FrVar,
     ) -> Result<(), SynthesisError> {
         trace!("enforcing next epoch");
         let previous_plus_one =
-            previous_index.add_constant(cs.ns(|| "previous plus_one"), &Fr::one())?;
+            previous_index + Fr::one();
+//            previous_index.add_constant(&Fr::one())?;
 
         let index_bit =
-            YToBitGadget::<Parameters>::is_eq_zero(&mut cs.ns(|| "is index zero"), index)?.not();
+            index.is_eq_zero()?.not();
+
         index.conditional_enforce_equal(
-            cs.ns(|| "index enforce equal"),
             &previous_plus_one,
             &index_bit,
         )?;
@@ -155,11 +155,10 @@ impl EpochData<Bls12_377> {
 
     /// Packs the provided bits in U8s, and calculates the hash and the counter
     /// Also returns the auxiliary CRH and XOF bits for potential compression from consumers
-    fn hash_bits_to_g1<CS: ConstraintSystem<Fr>>(
-        cs: &mut CS,
-        epoch_bits: &[Boolean],
+    fn hash_bits_to_g1(
+        epoch_bits: &[Bool],
         generate_constraints_for_hash: bool,
-    ) -> Result<(G1Gadget, Vec<Boolean>, Vec<Boolean>), SynthesisError> {
+    ) -> Result<(G1Var, Vec<Bool>, Vec<Bool>), SynthesisError> {
         trace!("hashing epoch to g1");
         // Reverse to LE
         let mut epoch_bits = epoch_bits.to_vec();
@@ -168,12 +167,12 @@ impl EpochData<Bls12_377> {
         let is_setup = is_setup(&epoch_bits);
 
         // Pack them to Uint8s
-        let input_bytes_var: Vec<UInt8> = epoch_bits
+        let input_bytes_var: Vec<U8> = epoch_bits
             .chunks(8)
             .map(|chunk| {
                 let mut chunk = chunk.to_vec();
                 if chunk.len() < 8 {
-                    chunk.resize(8, Boolean::constant(false));
+                    chunk.resize(8, Bool::constant(false));
                 }
                 UInt8::from_bits_le(&chunk)
             })
@@ -186,7 +185,7 @@ impl EpochData<Bls12_377> {
             // find the counter value for the hash
             let input_bytes = input_bytes_var
                 .iter()
-                .map(|b| b.get_value().get())
+                .map(|b| b.value())
                 .collect::<Result<Vec<_>, _>>()?;
 
             let (_, counter) = COMPOSITE_HASH_TO_G1
@@ -195,9 +194,9 @@ impl EpochData<Bls12_377> {
             counter
         };
 
-        let counter_var = UInt8::alloc(&mut cs.ns(|| "alloc counter"), || Ok(counter as u8))?;
-        HashToGroupGadget::<Parameters>::enforce_hash_to_group(
-            &mut cs.ns(|| "hash to group"),
+        let counter_var = UInt8::new_witness(epoch_bits.cs().unwrap_or(ConstraintSystemRef::None),
+        || Ok(counter as u8))?;
+        HashToGroupGadget::enforce_hash_to_group(
             counter_var,
             &input_bytes_var,
             generate_constraints_for_hash,
diff --git a/crates/epoch-snark/src/gadgets/epochs.rs b/crates/epoch-snark/src/gadgets/epochs.rs
index 18c664f..67d7b4b 100644
--- a/crates/epoch-snark/src/gadgets/epochs.rs
+++ b/crates/epoch-snark/src/gadgets/epochs.rs
@@ -3,29 +3,31 @@
 //! Prove the validator state transition function for the BLS 12-377 curve.
 
 use algebra::{
-    bls12_377::{Bls12_377, G1Projective, G2Projective, Parameters},
+    curves::bls12::Bls12Parameters,
+    bls12_377::{Bls12_377, G1Projective, G2Projective, Parameters as Bls12_377_Parameters},
     bw6_761::Fr,
     PairingEngine, ProjectiveCurve,
 };
 use r1cs_std::prelude::*;
 use r1cs_std::{
-    bls12_377::{G1Gadget, G2Gadget, PairingGadget},
-    bls12_377::{G1PreparedGadget, G2PreparedGadget},
-    fields::fp::FpGadget,
-    pairing::PairingGadget as _,
+    bls12_377::{G1Var, G2Var, PairingVar},
+    bls12_377::{G1PreparedVar, G2PreparedVar},
+    fields::fp::FpVar,
+    pairing::PairingVar as _,
     Assignment,
 };
 use tracing::{debug, info, span, Level};
 
-use r1cs_core::{ConstraintSynthesizer, ConstraintSystem, SynthesisError};
+use r1cs_core::{ConstraintSystemRef, ConstraintSynthesizer, SynthesisError};
 
 use groth16::{Proof, VerifyingKey};
 
 use crate::gadgets::{g2_to_bits, single_update::SingleUpdate, EpochBits, EpochData};
 
-use bls_gadgets::{BlsVerifyGadget, YToBitGadget};
-type BlsGadget = BlsVerifyGadget<Bls12_377, Fr, PairingGadget>;
-type FrGadget = FpGadget<Fr>;
+use bls_gadgets::{BlsVerifyGadget, FpUtils};
+type BlsGadget = BlsVerifyGadget<Bls12_377, Fr, PairingVar>;
+type FrVar = FpVar<Fr>;
+type Bool = Boolean<<Bls12_377_Parameters as Bls12Parameters>::Fp>;
 
 #[derive(Clone)]
 /// Contains the initial epoch block, followed by a list of epoch block transitions. The
@@ -81,15 +83,15 @@ impl<E: PairingEngine> ValidatorSetUpdate<E> {
 impl ConstraintSynthesizer<Fr> for ValidatorSetUpdate<Bls12_377> {
     // Enforce that the signatures over the epochs have been calculated
     // correctly, and then compress the public inputs
-    fn generate_constraints<CS: ConstraintSystem<Fr>>(
+    fn generate_constraints(
         self,
-        cs: &mut CS,
+        cs: ConstraintSystemRef<Fr>,
     ) -> Result<(), SynthesisError> {
         let span = span!(Level::TRACE, "ValidatorSetUpdate");
         let _enter = span.enter();
         info!("generating constraints");
-        let epoch_bits = self.enforce(&mut cs.ns(|| "check signature"))?;
-        epoch_bits.verify(&mut cs.ns(|| "compress public inputs"), self.hash_helper)?;
+        let epoch_bits = self.enforce(cs)?;
+        epoch_bits.verify(self.hash_helper, epoch_bits.first_epoch_bits[0].cs().unwrap_or(ConstraintSystemRef::None))?;
 
         info!("constraints generated");
 
@@ -98,14 +100,14 @@ impl ConstraintSynthesizer<Fr> for ValidatorSetUpdate<Bls12_377> {
 }
 
 impl ValidatorSetUpdate<Bls12_377> {
-    fn enforce<CS: ConstraintSystem<Fr>>(&self, cs: &mut CS) -> Result<EpochBits, SynthesisError> {
+    fn enforce(&self, cs: ConstraintSystemRef<<Bls12_377_Parameters as Bls12Parameters>::Fp>) -> Result<EpochBits, SynthesisError> {
         let span = span!(Level::TRACE, "ValidatorSetUpdate_enforce");
         let _enter = span.enter();
 
         debug!("converting initial EpochData to_bits");
         // Constrain the initial epoch and get its bits
         let (first_epoch_bits, first_epoch_index, initial_maximum_non_signers, initial_pubkey_vars) =
-            self.initial_epoch.to_bits(&mut cs.ns(|| "initial epoch"))?;
+            self.initial_epoch.to_bits(cs)?;
 
         // Constrain all intermediate epochs, and get the aggregate pubkey and epoch hash
         // from each one, to be used for the batch verification
@@ -117,7 +119,6 @@ impl ValidatorSetUpdate<Bls12_377> {
             prepared_aggregated_public_keys,
             prepared_message_hashes,
         ) = self.verify_intermediate_epochs(
-            &mut cs.ns(|| "verify epochs"),
             first_epoch_index,
             initial_pubkey_vars,
             initial_maximum_non_signers,
@@ -126,9 +127,9 @@ impl ValidatorSetUpdate<Bls12_377> {
         // Verify the aggregate BLS signature
         debug!("verifying bls signature");
         self.verify_signature(
-            &mut cs.ns(|| "verify aggregated signature"),
             &prepared_aggregated_public_keys,
             &prepared_message_hashes,
+            first_epoch_bits.cs().unwrap_or(ConstraintSystemRef::None)
         )?;
 
         Ok(EpochBits {
@@ -143,31 +144,30 @@ impl ValidatorSetUpdate<Bls12_377> {
     /// and generates the witness data necessary for the final BLS Sig
     /// verification and witness compression
     #[allow(clippy::type_complexity)]
-    fn verify_intermediate_epochs<CS: ConstraintSystem<Fr>>(
+    fn verify_intermediate_epochs(
         &self,
-        cs: &mut CS,
-        first_epoch_index: FrGadget,
-        initial_pubkey_vars: Vec<G2Gadget>,
-        initial_max_non_signers: FrGadget,
+        first_epoch_index: FrVar,
+        initial_pubkey_vars: Vec<G2Var>,
+        initial_max_non_signers: FrVar,
     ) -> Result<
         (
-            Vec<Boolean>,
-            Vec<Boolean>,
-            Vec<Boolean>,
-            Vec<G2PreparedGadget>,
-            Vec<G1PreparedGadget>,
+            Vec<Bool>,
+            Vec<Bool>,
+            Vec<Bool>,
+            Vec<G2PreparedVar>,
+            Vec<G1PreparedVar>,
         ),
         SynthesisError,
     > {
         let span = span!(Level::TRACE, "verify_intermediate_epochs");
         let _enter = span.enter();
 
-        let dummy_pk = G2Gadget::alloc_constant(
-            cs.ns(|| "dummy public key"),
+        let dummy_pk = G2Var::new_constant(
+            first_epoch_index.cs().unwrap_or(ConstraintSystemRef::None),
             G2Projective::prime_subgroup_generator(),
         )?;
-        let dummy_message = G1Gadget::alloc_constant(
-            cs.ns(|| "dummy sig"),
+        let dummy_message = G1Var::new_constant(
+            first_epoch_index.cs().unwrap_or(ConstraintSystemRef::None),
             G1Projective::prime_subgroup_generator(),
         )?;
 
@@ -183,7 +183,6 @@ impl ValidatorSetUpdate<Bls12_377> {
             let span = span!(Level::TRACE, "index", i);
             let _enter = span.enter();
             let constrained_epoch = epoch.constrain(
-                &mut cs.ns(|| format!("epoch {}", i)),
                 &previous_pubkey_vars,
                 &previous_epoch_index,
                 &previous_max_non_signers,
@@ -191,15 +190,10 @@ impl ValidatorSetUpdate<Bls12_377> {
                 self.hash_helper.is_none(), // generate constraints in BW6_761 if no helper was provided
             )?;
 
-            let index_bit = YToBitGadget::<Parameters>::is_eq_zero(
-                &mut cs.ns(|| format!("is index {} zero", i)),
-                &constrained_epoch.index,
-            )?
-            .not();
+            let index_bit = constrained_epoch.index.is_eq_zero()?.not();
 
             // Update the pubkeys for the next iteration
-            previous_epoch_index = FrGadget::conditionally_select(
-                cs.ns(|| format!("conditionally update previous epoch index {}", i)),
+            previous_epoch_index = FrVar::conditionally_select(
                 &index_bit,
                 &constrained_epoch.index,
                 &previous_epoch_index,
@@ -209,45 +203,37 @@ impl ValidatorSetUpdate<Bls12_377> {
                 .iter()
                 .zip(previous_pubkey_vars.iter())
                 .enumerate()
-                .map(|(j, (new_pk, old_pk))| {
-                    G2Gadget::conditionally_select(
-                        cs.ns(|| {
-                            format!("conditionally update previous pub key {} in epoch {}", j, i)
-                        }),
+                .map(|(_j, (new_pk, old_pk))| {
+                    G2Var::conditionally_select(
                         &index_bit,
                         new_pk,
                         old_pk,
                     )
                 })
                 .collect::<Result<Vec<_>, _>>()?;
-            previous_max_non_signers = FrGadget::conditionally_select(
-                cs.ns(|| format!("conditionally update previous max non signers {}", i)),
+            previous_max_non_signers = FrVar::conditionally_select(
                 &index_bit,
                 &constrained_epoch.new_max_non_signers,
                 &previous_max_non_signers,
             )?;
 
-            let aggregate_pk = G2Gadget::conditionally_select(
-                cs.ns(|| format!("conditionally select aggregate pk in epoch {}", i)),
+            let aggregate_pk = G2Var::conditionally_select(
                 &index_bit,
                 &constrained_epoch.aggregate_pk,
                 &dummy_pk,
             )?;
 
-            let prepared_aggregate_pk = PairingGadget::prepare_g2(
-                cs.ns(|| format!("prepare aggregate pk in epoch {}", i)),
+            let prepared_aggregate_pk = PairingVar::prepare_g2(
                 &aggregate_pk,
             )?;
 
-            let message_hash = G1Gadget::conditionally_select(
-                cs.ns(|| format!("conditionally select message hash in epoch {}", i)),
+            let message_hash = G1Var::conditionally_select(
                 &index_bit,
                 &constrained_epoch.message_hash,
                 &dummy_message,
             )?;
 
-            let prepared_message_hash = PairingGadget::prepare_g1(
-                cs.ns(|| format!("prepare message hash in epoch {}", i)),
+            let prepared_message_hash = PairingVar::prepare_g1(
                 &message_hash,
             )?;
 
@@ -260,17 +246,15 @@ impl ValidatorSetUpdate<Bls12_377> {
             all_xof_bits.extend_from_slice(&constrained_epoch.xof_bits);
             if i == self.epochs.len() - 1 {
                 let last_apk = BlsGadget::enforce_aggregated_all_pubkeys(
-                    cs.ns(|| "last epoch aggregated pk"),
                     &previous_pubkey_vars, // These are now the last epoch new pubkeys
                 )?;
                 let last_apk_bits =
-                    g2_to_bits(&mut cs.ns(|| "last epoch aggregated pk bits"), &last_apk)?;
+                    g2_to_bits(&last_apk)?;
                 last_epoch_bits = constrained_epoch.bits;
                 last_epoch_bits.extend_from_slice(&last_apk_bits);
 
                 // make sure the last epoch index is not zero
                 index_bit.enforce_equal(
-                    cs.ns(|| "last epoch index is not zero"),
                     &Boolean::Constant(true),
                 )?;
             }
@@ -289,17 +273,16 @@ impl ValidatorSetUpdate<Bls12_377> {
     }
 
     // Verify the aggregate signature
-    fn verify_signature<CS: ConstraintSystem<Fr>>(
+    fn verify_signature(
         &self,
-        cs: &mut CS,
-        pubkeys: &[G2PreparedGadget],
-        messages: &[G1PreparedGadget],
+        pubkeys: &[G2PreparedVar],
+        messages: &[G1PreparedVar],
+        cs: ConstraintSystemRef<<Bls12_377_Parameters as Bls12Parameters>::Fp>
     ) -> Result<(), SynthesisError> {
-        let aggregated_signature = G1Gadget::alloc(cs.ns(|| "aggregated signature"), || {
+        let aggregated_signature = G1Var::new_witness(cs, || {
             self.aggregated_signature.get()
         })?;
         BlsGadget::batch_verify_prepared(
-            cs.ns(|| "batch verify BLS"),
             &pubkeys,
             &messages,
             &aggregated_signature,
diff --git a/crates/epoch-snark/src/gadgets/hash_to_bits.rs b/crates/epoch-snark/src/gadgets/hash_to_bits.rs
index 840e59c..0bc8187 100644
--- a/crates/epoch-snark/src/gadgets/hash_to_bits.rs
+++ b/crates/epoch-snark/src/gadgets/hash_to_bits.rs
@@ -2,13 +2,14 @@ use algebra::{
     bls12_377::{Fr, FrParameters},
     FpParameters,
 };
-use r1cs_core::{ConstraintSynthesizer, ConstraintSystem, SynthesisError};
+use r1cs_core::{ConstraintSystemRef, ConstraintSynthesizer, SynthesisError};
 use tracing::{debug, info, span, trace, Level};
 
 use bls_crypto::SIG_DOMAIN;
 use bls_gadgets::hash_to_bits;
+use crate::gadgets::constrain_bool;
 
-use super::{constrain_bool, MultipackGadget};
+use super::MultipackGadget;
 
 #[derive(Clone)]
 /// Gadget which converts its inputs to Boolean constraints, applies blake2x to them
@@ -34,9 +35,9 @@ impl HashToBits {
 
 impl ConstraintSynthesizer<Fr> for HashToBits {
     #[allow(clippy::cognitive_complexity)] // false positive triggered by the info!("generating constraints") log
-    fn generate_constraints<CS: ConstraintSystem<Fr>>(
+    fn generate_constraints(
         self,
-        cs: &mut CS,
+        cs: ConstraintSystemRef<Fr>,
     ) -> Result<(), SynthesisError> {
         let span = span!(Level::TRACE, "HashToBits");
         info!("generating constraints");
@@ -48,10 +49,12 @@ impl ConstraintSynthesizer<Fr> for HashToBits {
         let mut xof_bits = vec![];
         for (i, message_bits) in self.message_bits.iter().enumerate() {
             trace!(epoch = i, "hashing to bits");
-            let bits = constrain_bool(&mut cs.ns(|| i.to_string()), &message_bits)?;
+            let bits = constrain_bool(&message_bits, cs.clone())?;
+            /*let bits = message_bits.iter().enumerate()
+                .map(|(j,b)| Boolean::new_witness(cs, || b.get()))
+                .collect::<Result<Vec<_>, _>>();*/
             let hash = hash_to_bits(
-                cs.ns(|| format!("{}: hash to bits", i)),
-                &bits,
+                &bits[..],
                 512,
                 personalization,
                 true,
@@ -63,14 +66,12 @@ impl ConstraintSynthesizer<Fr> for HashToBits {
         // Pack them as public inputs
         debug!(capacity = FrParameters::CAPACITY, "packing CRH bits");
         MultipackGadget::pack(
-            cs.ns(|| "pack messages"),
-            &all_bits,
+            &all_bits[..],
             FrParameters::CAPACITY as usize,
             true,
         )?;
         debug!(capacity = FrParameters::CAPACITY, "packing XOF bits");
         MultipackGadget::pack(
-            cs.ns(|| "pack xof bits"),
             &xof_bits,
             FrParameters::CAPACITY as usize,
             true,
diff --git a/crates/epoch-snark/src/gadgets/mod.rs b/crates/epoch-snark/src/gadgets/mod.rs
index 64d87d4..f589a85 100644
--- a/crates/epoch-snark/src/gadgets/mod.rs
+++ b/crates/epoch-snark/src/gadgets/mod.rs
@@ -17,14 +17,19 @@ mod epochs;
 pub use epochs::{HashToBitsHelper, ValidatorSetUpdate};
 
 // some helpers
-use algebra::{bls12_377::Parameters, bw6_761::Fr, BigInteger, Field, FpParameters, PrimeField};
+use algebra::{
+    curves::bls12::Bls12Parameters,
+    bls12_377::{Parameters as Bls12_377_Parameters},
+    bw6_761::Fr, 
+    BigInteger, FpParameters, PrimeField};
 use r1cs_std::prelude::*;
-use r1cs_std::{bls12_377::G2Gadget, fields::fp::FpGadget, Assignment};
+use r1cs_std::{bls12_377::G2Var, fields::fp::FpVar, Assignment};
 
-type FrGadget = FpGadget<Fr>;
+type FrVar = FpVar<Fr>;
+pub type Bool = Boolean<<Bls12_377_Parameters as Bls12Parameters>::Fp>;
 use bls_gadgets::YToBitGadget;
 
-use r1cs_core::{ConstraintSystem, SynthesisError};
+use r1cs_core::{SynthesisError, ConstraintSystemRef};
 
 #[cfg(test)]
 pub mod test_helpers {
@@ -69,31 +74,28 @@ pub(super) fn pack<F: PrimeField, P: FpParameters>(
         .collect::<Result<Vec<_>, _>>()
 }
 
-fn to_fr<T: Into<u64>, CS: ConstraintSystem<Fr>>(
-    cs: &mut CS,
+/*fn to_fr<T: Into<u64>>(
     num: Option<T>,
-) -> Result<FrGadget, SynthesisError> {
-    FrGadget::alloc(cs, || Ok(Fr::from(num.get()?.into())))
-}
+    cs: ConstraintSystemRef,
+) -> Result<FrVar, SynthesisError> {
+    FrVar::new_witness(cs, || Ok(Fr::from(num.get()?.into())))
+}*/
 
-fn fr_to_bits<CS: ConstraintSystem<Fr>>(
-    cs: &mut CS,
-    input: &FrGadget,
+fn fr_to_bits(
+    input: &FrVar,
     length: usize,
-) -> Result<Vec<Boolean>, SynthesisError> {
-    let mut input = input.to_bits(cs.ns(|| "input to bits"))?;
+) -> Result<Vec<Bool>, SynthesisError> {
+    let mut input = input.to_bits_le()?;
     input.reverse();
     Ok(input[0..length].to_vec())
 }
 
-fn g2_to_bits<CS: ConstraintSystem<Fr>>(
-    cs: &mut CS,
-    input: &G2Gadget,
-) -> Result<Vec<Boolean>, SynthesisError> {
-    let x_0 = input.x.c0.to_bits(cs.ns(|| "aggregated pub key c0 bits"))?;
-    let x_1 = input.x.c1.to_bits(cs.ns(|| "aggregated pub key c1 bits"))?;
-    let y_bit =
-        YToBitGadget::<Parameters>::y_to_bit_g2(cs.ns(|| "aggregated pub key y bit"), &input)?;
+fn g2_to_bits(
+    input: &G2Var,
+) -> Result<Vec<Bool>, SynthesisError> {
+    let x_0 = input.x.c0.to_bits_le()?;
+    let x_1 = input.x.c1.to_bits_le()?;
+    let y_bit = input.y_to_bit()?;
     let mut output = Vec::new();
     output.extend_from_slice(&x_0);
     output.extend_from_slice(&x_1);
@@ -101,13 +103,13 @@ fn g2_to_bits<CS: ConstraintSystem<Fr>>(
     Ok(output)
 }
 
-fn constrain_bool<F: Field, CS: ConstraintSystem<F>>(
-    cs: &mut CS,
+fn constrain_bool<F: PrimeField>(
     input: &[Option<bool>],
-) -> Result<Vec<Boolean>, SynthesisError> {
+    cs: ConstraintSystemRef<F>,
+) -> Result<Vec<Boolean<F>>, SynthesisError> {
     input
         .iter()
         .enumerate()
-        .map(|(j, b)| Boolean::alloc(cs.ns(|| format!("{}", j)), || b.get()))
+        .map(|(_j, b)| Boolean::new_witness(cs.clone(), || b.get()))
         .collect::<Result<Vec<_>, _>>()
 }
diff --git a/crates/epoch-snark/src/gadgets/pack.rs b/crates/epoch-snark/src/gadgets/pack.rs
index 340ae8f..17ceadb 100644
--- a/crates/epoch-snark/src/gadgets/pack.rs
+++ b/crates/epoch-snark/src/gadgets/pack.rs
@@ -1,9 +1,17 @@
-use algebra::{BigInteger, FpParameters, PrimeField};
+use algebra::{
+    curves::bls12::Bls12Parameters,
+    bls12_377::{Parameters as Bls12_377_Parameters, FqParameters},
+    FpParameters, 
+    PrimeField
+};
+use algebra_core::biginteger::BigInteger;
 use bls_gadgets::utils::is_setup;
-use r1cs_core::SynthesisError;
-use r1cs_std::{fields::fp::FpGadget, prelude::*, Assignment};
+use r1cs_core::{ConstraintSystemRef, SynthesisError};
+use r1cs_std::{Assignment, fields::fp::FpVar, prelude::*};
 use tracing::{span, trace, Level};
 
+type Bool = Boolean<<Bls12_377_Parameters as Bls12Parameters>::Fp>;
+type Fp = FpVar<<Bls12_377_Parameters as Bls12Parameters>::Fp>;
 /// Gadget which packs and unpacks boolean constraints in field elements for efficiency
 pub struct MultipackGadget;
 
@@ -11,12 +19,12 @@ impl MultipackGadget {
     /// Packs the provided boolean constraints to a vector of field element gadgets of
     /// `element_size` each. If `should_alloc_input` is set to true, then the allocations
     /// will be made as public inputs.
-    pub fn pack<F: PrimeField, CS: r1cs_core::ConstraintSystem<F>>(
-        mut cs: CS,
-        bits: &[Boolean],
+    // TODO: In principle F should be more restricted here since pack specifically uses Bls12_377_Parameters
+    pub fn pack<F: PrimeField>(
+        bits: &[Boolean<F>],
         element_size: usize,
         should_alloc_input: bool,
-    ) -> Result<Vec<FpGadget<F>>, SynthesisError> {
+    ) -> Result<Vec<FpVar<F>>, SynthesisError> {
         let span = span!(Level::TRACE, "multipack_gadget");
         let _enter = span.enter();
         let mut packed = vec![];
@@ -24,27 +32,28 @@ impl MultipackGadget {
         for (i, chunk) in fp_chunks.enumerate() {
             trace!(iteration = i);
             let alloc = if should_alloc_input {
-                FpGadget::<F>::alloc_input
+                FpVar::<F>::new_input
             } else {
-                FpGadget::<F>::alloc
+                FpVar::<F>::new_witness
             };
-            let fp = alloc(cs.ns(|| format!("chunk {}", i)), || {
+            let fp = alloc(bits.cs().unwrap_or(ConstraintSystemRef::None),
+            || {
                 if is_setup(&chunk) {
                     return Err(SynthesisError::AssignmentMissing);
                 }
                 let fp_val = F::BigInt::from_bits(
                     &chunk
                         .iter()
-                        .map(|x| x.get_value().get())
+                        .map(|x| x.value())
                         .collect::<Result<Vec<bool>, _>>()?,
                 );
                 Ok(F::from_repr(fp_val).get()?)
             })?;
-            let fp_bits = fp.to_bits(cs.ns(|| format!("chunk bits {}", i)))?;
+            let fp_bits = fp.to_bits_le()?;
             let chunk_len = chunk.len();
             for j in 0..chunk_len {
-                fp_bits[F::Params::MODULUS_BITS as usize - chunk_len + j]
-                    .enforce_equal(cs.ns(|| format!("fp bit {} for chunk {}", j, i)), &chunk[j])?;
+                fp_bits[<FqParameters as FpParameters>::MODULUS_BITS as usize - chunk_len + j]
+                    .enforce_equal(&chunk[j])?;
             }
 
             packed.push(fp);
@@ -54,16 +63,15 @@ impl MultipackGadget {
 
     /// Unpacks the provided field element gadget to a vector of boolean constraints
     #[allow(unused)]
-    pub fn unpack<F: PrimeField, CS: r1cs_core::ConstraintSystem<F>>(
-        mut cs: CS,
-        packed: &[FpGadget<F>],
+    pub fn unpack(
+        packed: &[Fp],
         target_bits: usize,
         source_capacity: usize,
-    ) -> Result<Vec<Boolean>, SynthesisError> {
+    ) -> Result<Vec<Bool>, SynthesisError> {
         let bits_vecs = packed
             .iter()
             .enumerate()
-            .map(|(i, x)| x.to_bits(cs.ns(|| format!("elem {} bits", i))))
+            .map(|(i, x)| x.to_bits_le())
             .collect::<Result<Vec<_>, _>>()?;
         let mut bits = vec![];
         let mut chunk = 0;
@@ -75,7 +83,7 @@ impl MultipackGadget {
                 source_capacity as usize
             };
             bits.extend_from_slice(
-                &bits_vecs[chunk][<F::Params as FpParameters>::MODULUS_BITS as usize - diff..],
+                &bits_vecs[chunk][<FqParameters as FpParameters>::MODULUS_BITS as usize - diff..],
             );
             current_index += diff;
             chunk += 1;
diff --git a/crates/epoch-snark/src/gadgets/single_update.rs b/crates/epoch-snark/src/gadgets/single_update.rs
index 6d5a909..b390173 100644
--- a/crates/epoch-snark/src/gadgets/single_update.rs
+++ b/crates/epoch-snark/src/gadgets/single_update.rs
@@ -1,9 +1,15 @@
-use algebra::{bls12_377::Bls12_377, bw6_761::Fr, PairingEngine};
-use r1cs_core::{ConstraintSystem, SynthesisError};
+use algebra::{
+    curves::bls12::Bls12Parameters,
+    bls12_377::{Bls12_377, Parameters as Bls12_377_Parameters}, 
+    bw6_761::Fr, 
+    PairingEngine
+};
+use r1cs_core::{ConstraintSystemRef, SynthesisError};
 use r1cs_std::{
-    bls12_377::{G1Gadget, G2Gadget, PairingGadget},
+    R1CSVar,
+    bls12_377::{G1Var, G2Var, PairingVar},
     boolean::Boolean,
-    fields::fp::FpGadget,
+    fields::fp::FpVar,
 };
 
 use super::{constrain_bool, EpochData};
@@ -11,8 +17,9 @@ use bls_gadgets::BlsVerifyGadget;
 use tracing::{span, Level};
 
 // Instantiate the BLS Verification gadget
-type BlsGadget = BlsVerifyGadget<Bls12_377, Fr, PairingGadget>;
-type FrGadget = FpGadget<Fr>;
+type BlsGadget = BlsVerifyGadget<Bls12_377, Fr, PairingVar>;
+type FrVar = FpVar<Fr>;
+type Bool = Boolean<<Bls12_377_Parameters as Bls12Parameters>::Fp>;
 
 #[derive(Clone, Debug)]
 /// An epoch block transition which includes the new epoch block's metadata, as well as
@@ -40,22 +47,22 @@ impl<E: PairingEngine> SingleUpdate<E> {
 /// [`SingleUpdate.constrain`]: struct.SingleUpdate.html#method.constrain
 pub struct ConstrainedEpoch {
     /// The new validators for this epoch
-    pub new_pubkeys: Vec<G2Gadget>,
+    pub new_pubkeys: Vec<G2Var>,
     /// The new threshold needed for signatures
-    pub new_max_non_signers: FrGadget,
+    pub new_max_non_signers: FrVar,
     /// The epoch's G1 Hash
-    pub message_hash: G1Gadget,
+    pub message_hash: G1Var,
     /// The aggregate pubkey based on the bitmap of the validators
     /// of the previous epoch
-    pub aggregate_pk: G2Gadget,
+    pub aggregate_pk: G2Var,
     /// The epoch's index
-    pub index: FrGadget,
+    pub index: FrVar,
     /// Serialized epoch data containing the index, max non signers, aggregated pubkey and the pubkeys array
-    pub bits: Vec<Boolean>,
+    pub bits: Vec<Bool>,
     /// Aux data for proving the CRH->XOF hash outside of BW6_761
-    pub xof_bits: Vec<Boolean>,
+    pub xof_bits: Vec<Bool>,
     /// Aux data for proving the CRH->XOF hash outside of BW6_761
-    pub crh_bits: Vec<Boolean>,
+    pub crh_bits: Vec<Bool>,
 }
 
 impl SingleUpdate<Bls12_377> {
@@ -65,12 +72,11 @@ impl SingleUpdate<Bls12_377> {
     /// # Panics
     ///
     /// - If `num_validators != self.epoch_data.public_keys.len()`
-    pub fn constrain<CS: ConstraintSystem<Fr>>(
+    pub fn constrain(
         &self,
-        cs: &mut CS,
-        previous_pubkeys: &[G2Gadget],
-        previous_epoch_index: &FrGadget,
-        previous_max_non_signers: &FrGadget,
+        previous_pubkeys: &[G2Var],
+        previous_epoch_index: &FrVar,
+        previous_max_non_signers: &FrVar,
         num_validators: u32,
         generate_constraints_for_hash: bool,
     ) -> Result<ConstrainedEpoch, SynthesisError> {
@@ -81,18 +87,16 @@ impl SingleUpdate<Bls12_377> {
 
         // Get the constrained epoch data
         let epoch_data = self.epoch_data.constrain(
-            &mut cs.ns(|| "constrain"),
             previous_epoch_index,
             generate_constraints_for_hash,
         )?;
 
         // convert the bitmap to constraints
-        let signed_bitmap = constrain_bool(&mut cs.ns(|| "signed bitmap"), &self.signed_bitmap)?;
+        let signed_bitmap = constrain_bool(&self.signed_bitmap, previous_epoch_index.cs().unwrap_or(ConstraintSystemRef::None))?;
 
         // Verify that the bitmap is consistent with the pubkeys read from the
         // previous epoch and prepare the message hash and the aggregate pk
         let (message_hash, aggregated_public_key) = BlsGadget::enforce_bitmap(
-            cs.ns(|| "verify signature partial"),
             previous_pubkeys,
             &signed_bitmap,
             &epoch_data.message_hash,
